<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Lanvan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover">
  <meta name="format-detection" content="telephone=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="default">
  
  <!-- 🚀 INSTANT DARK MODE - NO FLASH! -->
  <script>
    // Apply dark mode IMMEDIATELY before page renders to prevent flash
    (function() {
      const savedDarkMode = localStorage.getItem('dark_mode_enabled');
      let isDarkMode = false;  // Default to light mode
      
      if (savedDarkMode !== null) {
        isDarkMode = savedDarkMode === '1';
      }
      // Removed system preference check to ensure light mode is default
      
      if (isDarkMode) {
        document.documentElement.setAttribute('data-theme', 'dark');
      }
    })();
  </script>
  
  <link rel="stylesheet" href="{{ request.url_for('static', path='css/style.css') }}">
  <link rel="stylesheet" href="{{ request.url_for('static', path='css/main-styles.css') }}">
  
<!-- JSZip Library for creating ZIP files -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

<!-- Extracted File Utils -->
<script src="{{ request.url_for('static', path='js/file-utils.js') }}"></script>

</head>
<body>


<header style="padding: 1rem; background-color: #ffffff; border-radius: 10px; box-shadow: 0 2px 6px rgba(0,0,0,0.05); margin-bottom: 1rem;">
  <!-- Title -->
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.8rem;">
    <h1 style="margin: 0; font-size: 1.8rem; color: var(--text-color);">{{ msg }}</h1>
    
    <!-- AES Toggle Block (keep on right side) -->
    <div style="display: flex; align-items: center; gap: 0.8rem;">
      <!-- Dark Mode Toggle -->
      <div class="toggle-container" style="display: flex; align-items: center; background-color: var(--toggle-bg); padding: 0.5rem 0.8rem; border-radius: 25px; gap: 0.6rem; transition: background-color 0.3s ease;">
        <span id="darkModeLabel" style="font-size: 0.95rem; color: var(--toggle-text); transition: color 0.3s ease;"><b>🌙 Dark Mode</b></span>
        <label class="toggle-switch">
          <input type="checkbox" id="enableDarkMode">
          <span class="slider dark-mode-slider"></span>
        </label>
      </div>
      
      <!-- AES Encryption Toggle -->
      <div class="toggle-container" style="display: flex; align-items: center; background-color: var(--toggle-bg); padding: 0.5rem 0.8rem; border-radius: 25px; gap: 0.6rem; transition: background-color 0.3s ease;">
        <span style="font-size: 0.95rem; color: var(--toggle-text); transition: color 0.3s ease;"><b>AES Encryption</b></span>
        <label class="toggle-switch">
          <input type="checkbox" id="enableEncryption">
          <span class="slider"></span>
        </label>
      </div>
    </div>
  </div>
  
  <!-- Protocol Status and Settings Row -->
  <div style="display: flex; justify-content: space-between; align-items: center; gap: 0.5rem;">
    <div id="protocolStatus" onclick="showConnectionInfo()" style="display: flex; align-items: center; background-color: var(--protocol-bg); padding: 0.5rem 0.8rem; border-radius: 20px; gap: 0.5rem; font-size: 0.85rem; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.backgroundColor='#d0e9f7'" onmouseout="this.style.backgroundColor='var(--protocol-bg)'">
      <span id="protocolIcon">🌐</span>
      <span id="protocolText" style="color: var(--protocol-text); font-weight: 500; transition: color 0.3s ease;">HTTP</span>
      <span id="qrHintText" style="color: var(--protocol-text); font-size: 0.75rem; opacity: 0.8; font-weight: 400; transition: all 0.3s ease;">• Click for QR code</span>
    </div>
    
    <!-- Settings Button -->
    <div style="position: relative;">
      <button id="settingsBtn" onclick="toggleSettingsMenu()" style="
        background: var(--settings-bg);
        color: white;
        border: none;
        padding: 0.5rem 0.8rem;
        border-radius: 25px;
        cursor: pointer;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 0.3rem;
        transition: all 0.3s ease;
      " onmouseover="this.style.background='#5a6268'" onmouseout="this.style.background='var(--settings-bg)'">
        ⚙️ Settings
      </button>
    </div>
  </div>
  
  <!-- Settings Dropdown Menu (positioned below AES toggle) -->
  <div id="settingsMenu" style="
    display: none;
    position: absolute;
    right: 1rem;
    top: 6rem;
    background: var(--section-bg);
    border-radius: 10px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.15);
    border: 1px solid var(--border-color);
    min-width: 200px;
    z-index: 1000;
    overflow: hidden;
  ">
    <button onclick="toggleDeviceLogs(); toggleSettingsMenu();" style="
      width: 100%;
      padding: 0.8rem 1rem;
      border: none;
      background: var(--section-bg);
      color: var(--text-color);
      text-align: left;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: background-color 0.2s ease;
    " onmouseover="this.style.background='var(--input-bg)'" onmouseout="this.style.background='var(--section-bg)'">
      📊 Device Logs
    </button>
    <div style="height: 1px; background: var(--border-color); margin: 0;"></div>
    <button onclick="showAccessControlSettings(); toggleSettingsMenu();" style="
      width: 100%;
      padding: 0.8rem 1rem;
      border: none;
      background: var(--section-bg);
      color: var(--text-color);
      text-align: left;
      cursor: pointer;
      font-size: 0.9rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      transition: background-color 0.2s ease;
    " onmouseover="this.style.background='var(--input-bg)'" onmouseout="this.style.background='var(--section-bg)'" title="Coming soon - Access control features">
      🔐 Access Control <span style="font-size: 0.7rem; opacity: 0.6; color: var(--text-color);">(Soon)</span>
    </button>
  </div>
</header>

{% if not show_clipboard_only or show_both_sections %}
<!--  Upload Files & Manager (Merged Section) -->
<section id="fileTransferSection" style="{% if default_view == 'clipboard' %}display: none;{% endif %}">
  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
    <h2 style="margin: 0; color: var(--text-color);">📤 Upload Files & Manager</h2>
    <div style="position: relative;">
      <button onclick="showSwitchDropdown(event, 'switchDropdownMain')" class="clipboard-btn" style="
        background: linear-gradient(135deg, #6c5ce7, #a29bfe);
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.9rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
        transition: all 0.3s ease;
        box-shadow: 0 2px 4px rgba(108, 92, 231, 0.3);
      " title="Switch between File Sharing and Clipboard">
        🔄 Switch
      </button>
      <div id="switchDropdownMain" style="display:none; position:absolute; right:0; top:110%; background:var(--section-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.15); min-width:150px; z-index:10001;">
        <div style="padding:0.5rem 1rem; cursor:pointer; display: flex; align-items: center; justify-content: space-between; white-space: nowrap; gap: 0.5rem; color: var(--text-color); transition: background-color 0.2s ease;" onclick="switchToPage('file')" onmouseover="this.style.backgroundColor='var(--input-bg)'" onmouseout="this.style.backgroundColor='transparent'">
          <span style="display: flex; align-items: center; gap: 0.5rem; white-space: nowrap; color: var(--text-color);">
            <span style="font-size: 1.3em;">📁</span>
            <span>File Sharing</span>
          </span>
          <span id="fileTickMain" style="color: #7c3aed; font-size: 1.3em; margin-left: 10px; display: {% if not show_clipboard_only %}inline{% else %}none{% endif %};">✔️</span>
        </div>
        <div style="padding:0.5rem 1rem; cursor:pointer; display: flex; align-items: center; justify-content: space-between; white-space: nowrap; gap: 0.5rem; color: var(--text-color); transition: background-color 0.2s ease;" onclick="switchToPage('clipboard')" onmouseover="this.style.backgroundColor='var(--input-bg)'" onmouseout="this.style.backgroundColor='transparent'">
          <span style="display: flex; align-items: center; gap: 0.5rem; white-space: nowrap; color: var(--text-color);">
            <span style="font-size: 1.3em;">📋</span>
            <span>Clipboard</span>
          </span>
          <span id="clipboardTickMain" style="color: #7c3aed; font-size: 1.3em; margin-left: 10px; display: {% if show_clipboard_only %}inline{% else %}none{% endif %};">✔️</span>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Upload Form -->
  <form id="unifiedUploadForm">
    <div class="drop-zone" id="drop-zone">
      <p>📁 Drag & Drop files here or click to select</p>
      <input type="file" id="fileInput" name="files" multiple required>
      <div class="file-preview" id="file-preview"></div>
    </div>
    <progress id="uploadProgress" value="0" max="100"></progress>
    <p id="uploadStatus"></p>
  </form>

  <!-- Upload Manager (Always Visible) -->
  <div id="uploadManager" style="margin-top: 2rem; border-top: 2px solid #e0e0e0; padding-top: 1.5rem;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
      <h3 style="margin: 0; color: var(--text-color);">🚀 Active Uploads <span id="uploadCount" style="color: var(--text-color); font-size: 0.9rem;">(0)</span></h3>
      <div style="display: flex; gap: 0.5rem;">
        <button onclick="cancelAllUploads()" class="upload-manager-btn" style="background: #dc3545;">❌ Cancel All</button>
      </div>
    </div>
    
    <div id="uploadQueue" class="upload-queue">
      <!-- Upload items will be dynamically added here -->
    </div>
  </div>
  </section>
{% endif %}

{% if not show_clipboard_only or show_both_sections %}
<!-- 📂 File List -->
<section id="fileListSection" style="{% if default_view == 'clipboard' %}display: none;{% endif %}">
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <div>
      <h2 style="color: var(--text-color);">Available Files</h2>
      <span id="fileCount" class="file-count" style="color: var(--text-color); font-size: 0.9em; margin-left: 0.5rem;"></span>
    </div>
    <div style="display: flex; gap: 0.5rem;">
      <button onclick="refreshFileListManually()" class="download-btn" style="background-color: #17a2b8; margin-right: 0.5rem;" title="Refresh file list">🔄 Refresh</button>
      <button onclick="showDownloadOptions(event)" class="download-btn" style="margin-right: 0.5rem;">⬇ Download All</button>
      <button onclick="clearAllFiles()" class="download-btn" style="background-color: #e74c3c;">🧹 Clear History</button>
    </div>
  </div>

  {% if files %}
  <div id="fileGrid" class="file-grid">
    {% for file in files %}
    <div class="file-card">
      <div class="file-icon">📄</div>
      <div class="file-name" title="{{ file }}">{{ file }}</div>
      <a href="{{ url_for('download_file', filename=file) }}" download class="download-btn">⬇ Download</a>
    </div>
    {% endfor %}
  </div>
  {% else %}
  <div id="fileGrid" class="file-grid" style="display: none;">
    <!-- Files will be populated by JavaScript -->
  </div>
  {% endif %}
</section>
{% endif %}

{% if show_clipboard_only or show_both_sections %}
<!-- 📋 Clipboard System (Unified Layout) -->
<section id="clipboardSection" style="{% if default_view == 'file' %}display: none;{% endif %}">
  <div style="display: flex; justify-content: space-between; align-items: center;">
    <div>
      <h2>Clipboard System</h2>
    </div>
    <div style="display: flex; gap: 0.5rem; align-items: center;">
      <div style="position: relative;">
        <button onclick="showSwitchDropdown(event, 'switchDropdownClipboard')" class="clipboard-btn" style="background: linear-gradient(135deg, #6c5ce7, #a29bfe); color: white; border: none; padding: 0.5rem 1rem; border-radius: 8px; cursor: pointer; font-size: 0.9rem; display: flex; align-items: center; gap: 0.5rem; transition: all 0.3s ease; box-shadow: 0 2px 4px rgba(108, 92, 231, 0.3);" title="Switch between File Sharing and Clipboard">🔄 Switch</button>
        <div id="switchDropdownClipboard" style="display:none; position:absolute; right:0; top:110%; background:var(--section-bg); border:1px solid var(--border-color); border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.15); min-width:150px; z-index:10001;">
          <div style="padding:0.5rem 1rem; cursor:pointer; display: flex; align-items: center; justify-content: space-between; white-space: nowrap; gap: 0.5rem; color: var(--text-color); transition: background-color 0.2s ease;" onclick="switchToPage('file')" onmouseover="this.style.backgroundColor='var(--input-bg)'" onmouseout="this.style.backgroundColor='transparent'">
            <span style="display: flex; align-items: center; gap: 0.5rem; white-space: nowrap; color: var(--text-color);"><span style="font-size: 1.3em;">📁</span><span>File Sharing</span></span>
            <span id="fileTickClipboard" style="color: #7c3aed; font-size: 1.3em; margin-left: 10px; display: {% if not show_clipboard_only %}inline{% else %}none{% endif %};">✔️</span>
          </div>
          <div style="padding:0.5rem 1rem; cursor:pointer; display: flex; align-items: center; justify-content: space-between; white-space: nowrap; gap: 0.5rem; color: var(--text-color); transition: background-color 0.2s ease;" onclick="switchToPage('clipboard')" onmouseover="this.style.backgroundColor='var(--input-bg)'" onmouseout="this.style.backgroundColor='transparent'">
            <span style="display: flex; align-items: center; gap: 0.5rem; white-space: nowrap; color: var(--text-color);"><span style="font-size: 1.3em;">📋</span><span>Clipboard</span></span>
            <span id="clipboardTickClipboard" style="color: #7c3aed; font-size: 1.3em; margin-left: 10px; display: {% if show_clipboard_only %}inline{% else %}none{% endif %};">✔️</span>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Clipboard Input Section -->
  <div style="background: var(--section-bg); padding: 1rem; border-radius: 8px; margin: 1.5rem 0; border: 1px solid var(--border-color);">
    <h4 style="margin: 0 0 1rem 0; color: var(--text-color);">Add to Clipboard</h4>
    <div style="margin-bottom: 1rem;">
      <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: var(--text-color);">Paste Text/Content:</label>
      <textarea id="clipboardTextInput" placeholder="Type or paste text content here..." style="width: 100%; height: 100px; padding: 0.5rem; border: 2px dashed var(--border-color); background: var(--input-bg); color: var(--text-color); border-radius: 6px; resize: vertical; font-family: monospace; font-size: 0.9rem; white-space: pre-wrap; word-wrap: break-word;" onpaste="handleClipboardPaste(event)"></textarea>
      <small style="color: var(--text-color); font-size: 0.8rem;">💡 Supports: Text content and images (paste images directly with Ctrl+V)</small>
    </div>
    <div style="display: flex; gap: 0.5rem;">
      <button id="addTextToClipboardBtn" class="download-btn" style="background: #28a745; transition: all 0.2s ease;">📝 Add Text</button>
      <button onclick="clearClipboardInput()" class="download-btn" style="background: var(--settings-bg);">🧹 Clear Input</button>
    </div>
  </div>

  <!-- Clipboard History Section -->
  <div style="background: var(--section-bg); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color);">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
      <h4 style="margin: 0; color: var(--text-color);">📚 Clipboard History</h4>
      <div class="clipboard-buttons">
        <button onclick="refreshClipboardHistory()" class="download-btn" style="background: #17a2b8;">🔄 Refresh</button>
        <button onclick="downloadClipboardHistory()" class="download-btn" style="background: #28a745;">📄 Download</button>
        <button onclick="clearAllClipboardHistory()" class="download-btn" style="background: #dc3545;">🧹 Clear All</button>
      </div>
    </div>
    <div id="clipboardHistoryContent" style="max-height: 300px; overflow-y: auto; background: var(--input-bg); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color);">
      <div style="text-align: center; color: var(--text-color); padding: 2rem;">
        <div style="font-size: 3rem; margin-bottom: 1rem;">📋</div>
        <div>No clipboard items yet</div>
        <div style="font-size: 0.9rem; margin-top: 0.5rem;">Add content above to get started</div>
      </div>
    </div>
  </div>
</section>
{% endif %}

<!-- 📋 Clipboard Real-Time WebSocket Auto-Refresh -->
<script>
  // 🔧 Conditional Logging System - Production Performance Optimization
  const DEBUG_MODE = false; // Set to true for development, false for production
  const DEBUG_LEVELS = {
    ERROR: 0,   // Always shown (security, critical errors)
    WARN: 1,    // Important warnings
    INFO: 2,    // General information
    DEBUG: 3    // Detailed debugging (upload progress, etc.)
  };
  
  const currentLogLevel = DEBUG_MODE ? DEBUG_LEVELS.DEBUG : DEBUG_LEVELS.ERROR;
  
  // Optimized logging functions
  const log = {
    error: (msg, ...args) => {
      if (currentLogLevel >= DEBUG_LEVELS.ERROR) console.error('❌', msg, ...args);
    },
    warn: (msg, ...args) => {
      if (currentLogLevel >= DEBUG_LEVELS.WARN) console.warn('⚠️', msg, ...args);
    },
    info: (msg, ...args) => {
      if (currentLogLevel >= DEBUG_LEVELS.INFO) console.info('ℹ️', msg, ...args);
    },
    debug: (msg, ...args) => {
      if (currentLogLevel >= DEBUG_LEVELS.DEBUG) console.log('🔍', msg, ...args);
    },
    upload: (msg, ...args) => {
      if (currentLogLevel >= DEBUG_LEVELS.DEBUG) console.log('📤', msg, ...args);
    },
    network: (msg, ...args) => {
      if (currentLogLevel >= DEBUG_LEVELS.DEBUG) console.log('🌐', msg, ...args);
    }
  };

  // Clipboard WebSocket for clipboard-only mode
  if (typeof show_clipboard_only !== 'undefined' && show_clipboard_only) {
    let ws = null;
    function connectClipboardWS() {
      const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
      const wsUrl = `${protocol}://${window.location.host}/ws/clipboard`;
      ws = new WebSocket(wsUrl);
      ws.onopen = () => {
        //console.log('📡 Clipboard WebSocket connected');
        // Refresh clipboard history when WebSocket (re)connects
        if (typeof refreshClipboardHistory === 'function') {
          setTimeout(() => refreshClipboardHistory(), 50); // Reduced from 100ms for responsiveness
        }
      };
      ws.onmessage = (event) => {
        if (event.data === 'refresh') {
          if (typeof refreshClipboardHistory === 'function') refreshClipboardHistory();
        }
      };
      ws.onclose = () => {
        // Try to reconnect after reduced delay if disconnected
        setTimeout(connectClipboardWS, 1000); // Reduced from 2000ms
      };
      ws.onerror = () => {
        ws.close();
      };
    }
    document.addEventListener('DOMContentLoaded', connectClipboardWS);
    window.addEventListener('beforeunload', () => {
      if (ws) ws.close();
    });
  } else {
    // Clipboard WebSocket for regular mode (when both sections are available)
    let clipboardWS = null;
    function connectRegularClipboardWS() {
      // Only connect if clipboard section exists
      const clipboardSection = document.getElementById('clipboardSection');
      if (!clipboardSection) return;
      
      const protocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
      const wsUrl = `${protocol}://${window.location.host}/ws/clipboard`;
      clipboardWS = new WebSocket(wsUrl);
      clipboardWS.onopen = () => {
        log.network('Regular mode clipboard WebSocket connected');
        // Refresh clipboard history when WebSocket (re)connects
        if (typeof refreshClipboardHistory === 'function') {
          setTimeout(() => refreshClipboardHistory(), 50); // Reduced from 100ms for responsiveness
        }
      };
      clipboardWS.onmessage = (event) => {
        if (event.data === 'refresh') {
          log.debug('Clipboard update received via WebSocket');
          if (typeof refreshClipboardHistory === 'function') refreshClipboardHistory();
        }
      };
      clipboardWS.onclose = () => {
        log.warn('Clipboard WebSocket disconnected, will reconnect...');
        // Try to reconnect after reduced delay if disconnected
        setTimeout(connectRegularClipboardWS, 1000); // Reduced from 2000ms
      };
      clipboardWS.onerror = () => {
        clipboardWS.close();
      };
    }
    
    // Connect clipboard WebSocket when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      // Small delay to ensure clipboard functions are defined
      setTimeout(connectRegularClipboardWS, 1000);
    });
    
    window.addEventListener('beforeunload', () => {
      if (clipboardWS) clipboardWS.close();
    });
  }
</script>

<!-- 📡 Auto Upload JS -->
<script>
  // 🌐 Global Variables
    // Page mode detection
    const show_clipboard_only = {{ 'true' if show_clipboard_only else 'false' }};
    
    let droppedFiles = [];
    let isDragging = false;
    let isUploadInProgress = false;
    let pond;
    let uploadType = 'regular';
    let encryptionKey = null;
    let isEncryptionEnabled = false;
    let fetchInterceptorActive = false;
    
    // 📤 Upload Manager System - Make globally accessible
    window.uploadQueue = [];
    let uploadQueue = window.uploadQueue; // Local reference
    let uploadIdCounter = 0;
    let isUploadManagerVisible = false;
    
    // 🔄 Progress Update Safety Net - Ultra-responsive for live feel
    let progressUpdateInterval = null;
    
    function startProgressUpdateSafetyNet() {
      if (progressUpdateInterval) return; // Already running
      
      progressUpdateInterval = setInterval(() => {
        // Include ALL uploads that should show progress (uploading OR processing)
        const activeUploads = uploadQueue.filter(item => 
          (item.status === 'uploading' || item.status === 'processing') && 
          item.progress !== undefined && item.progress < 100
        );
        
        // Force update uploads that might be stuck due to processing delays
        activeUploads.forEach(uploadItem => {
          const timeSinceUpdate = uploadItem.lastProgressUpdate ? (Date.now() - uploadItem.lastProgressUpdate) : 5000;
          // More aggressive: force update every 800ms for ultra-responsive feel
          if (timeSinceUpdate > 800) {
            // Only log if critically stuck for more than 30 seconds to reduce spam
            if (timeSinceUpdate > 30000) {
              console.warn(`⚠️ Upload critically stuck for ${uploadItem.fileName} (${(timeSinceUpdate/1000).toFixed(1)}s), forcing update`);
            }
            updateUploadItem(uploadItem, true); // Force update flag
          }
        });
        
        // Keep safety net running if ANY uploads exist (not just active ones)
        const anyUploads = uploadQueue.filter(item => 
          !['completed', 'cancelled', 'error'].includes(item.status)
        );
        
        if (anyUploads.length === 0) {
          clearInterval(progressUpdateInterval);
          progressUpdateInterval = null;
          console.log('🔄 Safety net stopped - no active uploads');
        }
      }, 300); // Check every 300ms for ultra-responsive feel
    }
    
    // 🔒 AES Configuration (matches backend) - SIZE LIMITS REMOVED
    const AES_CONFIG = {
      MAX_FILE_SIZE_MB: null,     // No limit - streaming encryption
      MAX_FILE_SIZE_BYTES: null,  // No limit - streaming encryption
      HTTPS_ONLY: false,          // Disabled for testing
      ALGORITHM: 'AES-256-CBC'
    };

  // 🚀 Configuration Management - Centralized constants for better performance tuning
  const LANVAN_CONFIG = {
    // Memory thresholds
    CHUNK_THRESHOLD: 250 * 1024 * 1024, // 250MB - when to use chunked upload
    AES_SIZE_LIMIT: null,  // NO LIMIT - streaming encryption handles any size
    GUEST_MEMORY_LIMIT: 1024 * 1024 * 1024, // 1GB - guest device warning threshold
    
    // Unified chunk sizing for optimal performance (same for all device types)
    CHUNK_SIZES: {
      GUEST_INITIAL: 16 * 1024 * 1024,   // 16MB initial for guest devices (unified)
      GUEST_MIN: 2 * 1024 * 1024,        // 2MB minimum for guest devices (unified)
      GUEST_MAX: 128 * 1024 * 1024,      // 128MB maximum for guest devices (unified)
      REGULAR_INITIAL: 16 * 1024 * 1024, // 16MB initial for regular devices
      REGULAR_MIN: 2 * 1024 * 1024,      // 2MB minimum for regular devices
      REGULAR_MAX: 128 * 1024 * 1024     // 128MB maximum for regular devices
    },
    
    // Smart Concurrent Upload System
    CONCURRENT: {
      MAX_UPLOADS: 6,           // Maximum concurrent uploads
      MIN_UPLOADS: 1,           // Minimum concurrent uploads
      NETWORK_FAST: 3,          // Concurrent uploads for fast networks (>10MB/s)
      NETWORK_MEDIUM: 2,        // Concurrent uploads for medium networks (5-10MB/s)
      NETWORK_SLOW: 1,          // Concurrent uploads for slow networks (<5MB/s)
      ADAPTATION_INTERVAL: 5,   // Adapt every N uploads
      SPEED_SAMPLE_SIZE: 3,     // Number of speed samples to average
      CPU_THRESHOLD: 80,        // CPU usage threshold to reduce concurrency
      MEMORY_THRESHOLD: 85      // Memory usage threshold to reduce concurrency
    },
    
    // Performance tuning intervals (unified to reduce overhead)
    INTERVALS: {
      PROGRESS_UPDATE: 2500,  // Unified progress update interval (2.5s)
      TOAST_UPDATE: 2500,     // Toast update interval (matches progress)
      CHUNK_ADAPTATION: 3,    // Adapt chunk size every N chunks
      MEMORY_CHECK: 10        // Check memory every N chunks (guest devices)
    },
    
    // Network speed thresholds for chunk adaptation
    SPEED_THRESHOLDS: {
      ULTRA_FAST: 40,   // > 40 MB/s
      VERY_FAST: 25,    // > 25 MB/s  
      FAST: 15,         // > 15 MB/s
      MEDIUM_FAST: 8,   // > 8 MB/s
      MEDIUM: 4,        // > 4 MB/s
      SLOW: 2           // < 2 MB/s
    },
    
    // Memory management
    MEMORY: {
      HIGH_USAGE_THRESHOLD: 70, // Reduce chunk size above 70% memory usage
      GC_FREQUENCY: 10          // Force GC every N chunks on guest devices
    },
    
    // Error recovery and retry mechanisms
    ERROR_RECOVERY: {
      MAX_RETRIES: 3,           // Maximum retry attempts for failed chunks
      RETRY_DELAY: 1000,        // Base delay between retries (ms)
      EXPONENTIAL_BACKOFF: 2,   // Multiplier for exponential backoff
      NETWORK_TIMEOUT: 30000    // Network timeout for chunk uploads (30s)
    }
  };

  // 🎯 State Management - Centralized state tracking
  const LANVAN_STATE = {
    uploads: new Map(),         // Track active uploads by file ID
    downloads: new Map(),       // Track active downloads by file ID
    errors: [],                 // Error history for debugging
    performance: {              // Performance metrics
      totalUploaded: 0,
      totalDownloaded: 0,
      averageSpeed: 0,
      sessionsStartTime: Date.now()
    },
    ui: {
      activeToasts: 0,          // Track active toast count
      lastUpdate: 0             // Last UI update timestamp
    },
    memory: {
      lastCleanup: Date.now(),  // Last memory cleanup time
      cleanupInterval: 300000,  // Cleanup every 5 minutes
      maxErrorHistory: 10,      // Maximum error entries to keep
      maxFileMetadata: 50       // Maximum file metadata entries
    }
  };

  // 🧹 Memory Management & Cleanup Functions
  function performMemoryCleanup() {
    const now = Date.now();
    
    // Only run cleanup if enough time has passed
    if (now - LANVAN_STATE.memory.lastCleanup < LANVAN_STATE.memory.cleanupInterval) {
      return;
    }
    
    console.log('🧹 Performing memory cleanup...');
    
    // Cleanup error history
    if (LANVAN_STATE.errors.length > LANVAN_STATE.memory.maxErrorHistory) {
      LANVAN_STATE.errors.splice(0, LANVAN_STATE.errors.length - LANVAN_STATE.memory.maxErrorHistory);
    }
    
    // Cleanup localStorage file metadata
    try {
      const metadata = JSON.parse(localStorage.getItem('fileMetadata') || '{}');
      const entries = Object.entries(metadata);
      if (entries.length > LANVAN_STATE.memory.maxFileMetadata) {
        // Sort by timestamp and keep most recent
        const sorted = entries.sort((a, b) => (b[1].timestamp || 0) - (a[1].timestamp || 0));
        const newMetadata = {};
        sorted.slice(0, LANVAN_STATE.memory.maxFileMetadata).forEach(([key, value]) => {
          newMetadata[key] = value;
        });
        localStorage.setItem('fileMetadata', JSON.stringify(newMetadata));
        console.log(`🧹 Cleaned file metadata: ${entries.length} → ${LANVAN_STATE.memory.maxFileMetadata}`);
      }
    } catch (e) {
      console.log('⚠️ Error cleaning file metadata:', e);
    }
    
    // Cleanup transfer logs
    try {
      const logs = JSON.parse(localStorage.getItem('transferLogs') || '[]');
      if (logs.length > 20) {
        logs.splice(20);
        localStorage.setItem('transferLogs', JSON.stringify(logs));
        console.log('🧹 Cleaned transfer logs');
      }
    } catch (e) {
      console.log('⚠️ Error cleaning transfer logs:', e);
    }
    
    // Force garbage collection if available
    if (typeof window.gc === 'function') {
      window.gc();
      console.log('🧹 Forced garbage collection');
    }
    
    LANVAN_STATE.memory.lastCleanup = now;
  }

  // 🔄 Deduplication for rapid file selection changes
  let lastFileSelectionTime = 0;
  let lastFileSelectionHash = '';
  const FILE_SELECTION_DEBOUNCE = 500; // 500ms debounce
  // Removed shouldProcessFileSelection function; moved to file-utils.js

  // 🌐 Smart Concurrent Upload Management System
  let activeUploads = 0;
  let currentMaxConcurrent = LANVAN_CONFIG.CONCURRENT.NETWORK_MEDIUM; // Start with medium
  let networkSpeedSamples = [];
  let uploadCompletionTimes = [];
  let lastConcurrencyAdjustment = 0;
  let totalUploadsProcessed = 0;
  // Removed getOptimalConcurrency function; moved to file-utils.js

  function updateNetworkSpeed(speedMBps) {
    networkSpeedSamples.push(speedMBps);
    
    // Keep only recent samples
    if (networkSpeedSamples.length > LANVAN_CONFIG.CONCURRENT.SPEED_SAMPLE_SIZE) {
      networkSpeedSamples.shift();
    }
    
    // Adapt concurrency every N uploads
    totalUploadsProcessed++;
    if (totalUploadsProcessed % LANVAN_CONFIG.CONCURRENT.ADAPTATION_INTERVAL === 0) {
      const newOptimal = getOptimalConcurrency();
      if (newOptimal !== currentMaxConcurrent) {
        console.log(`📊 Adaptive concurrency: ${currentMaxConcurrent} → ${newOptimal} (avg speed: ${(networkSpeedSamples.reduce((a, b) => a + b, 0) / networkSpeedSamples.length).toFixed(1)} MB/s)`);
        currentMaxConcurrent = newOptimal;
        lastConcurrencyAdjustment = Date.now();
        
        // Update UI to reflect new concurrency
        updateUploadManager();
        
        // Start additional uploads if we increased concurrency
        if (newOptimal > activeUploads) {
          setTimeout(() => {
            startNextUpload();
          }, 100);
        }
      }
    }
  }
  
  function canStartUpload() {
    return activeUploads < currentMaxConcurrent;
  }
  
  function startUpload() {
    activeUploads++;
    log.upload(`Upload started (${activeUploads}/${currentMaxConcurrent} active, optimal: ${getOptimalConcurrency()})`);
    
    // Pause auto-refresh during uploads to avoid conflicts
    if (activeUploads === 1) {
      handleUploadStart();
    }
  }
  // Removed endUpload function; moved to file-utils.js
  // Removed createUploadItem function; moved to file-utils.js

  function addToUploadQueue(files) {
    // No batch grouping - process each file individually
    log.upload(`Adding ${files.length} file(s) to upload queue`);

    for (let file of files) {
      const uploadId = ++uploadIdCounter;
      const uploadItem = createUploadItem(file, uploadId);
      uploadQueue.push(uploadItem);
      renderUploadItem(uploadItem);
    }
    updateUploadManager();
    // Removed showUploadManager function; moved to file-utils.js
  }

  function showUploadManager() {
    const manager = document.getElementById('uploadManager');
    if (manager && !isUploadManagerVisible) {
      manager.style.display = 'block';
      isUploadManagerVisible = true;
      
      // 🔔 Show helpful toast when upload manager first appears
      showToast('📤 Upload Manager opened - Track your file uploads here!', 3000);
    }
  }

  // ⚙️ Settings Menu Functions
  function toggleSettingsMenu() {
    const settingsMenu = document.getElementById('settingsMenu');
    if (settingsMenu.style.display === 'none' || settingsMenu.style.display === '') {
      settingsMenu.style.display = 'block';
      // Close menu when clicking outside
      setTimeout(() => {
        document.addEventListener('click', closeSettingsOnOutsideClick);
      }, 100);
    } else {
      settingsMenu.style.display = 'none';
      document.removeEventListener('click', closeSettingsOnOutsideClick);
    }
  }

  // Removed closeSettingsOnOutsideClick function; moved to file-utils.js

  function showAccessControlSettings() {
    showToast('🔐 Access Control features coming soon! Stay tuned for host-guest permissions, device whitelisting, and access tokens.', 5000);
  }

  function toggleDeviceLogs() {
    // Open device logs in modal format
    const modal = document.getElementById('deviceLogsModal');
    modal.style.display = 'flex';
    
    // Populate logs data
    populateDeviceLogsModal();
    
    // Close on escape key
    document.addEventListener('keydown', function escapeHandler(e) {
      if (e.key === 'Escape') {
        closeDeviceLogsModal();
        document.removeEventListener('keydown', escapeHandler);
      }
    });
    
    // Close on background click
    modal.addEventListener('click', (e) => {
      if (e.target === modal) {
        closeDeviceLogsModal();
      }
    });
  }

  function closeDeviceLogsModal() {
    const modal = document.getElementById('deviceLogsModal');
    modal.style.display = 'none';
  }

  function populateDeviceLogsModal() {
    const logsSection = document.getElementById('deviceLogsSection');
    const logsContent = document.getElementById('deviceLogsContent');
    const logsStats = document.getElementById('deviceLogsStats');
    const logsPagination = document.getElementById('deviceLogsPagination');
    
    // Show logs in modal
    try {
      const deviceUploadLogs = getDeviceUploadHistory();
      
      if (deviceUploadLogs.length === 0) {
        logsContent.innerHTML = `
          <div style="text-align: center; color: var(--text-color); opacity: 0.6; padding: 2rem;">
            <div style="font-size: 3rem; margin-bottom: 1rem;">📊</div>
            <div style="font-size: 1.1rem; color: var(--text-color) !important;">No device logs for this session yet</div>
            <div style="font-size: 0.9rem; margin-top: 0.5rem; color: var(--text-color) !important; opacity: 0.7;">Upload some files to see activity logs here</div>
            <div style="font-size: 0.85rem; margin-top: 1rem; color: var(--text-color) !important; opacity: 0.7;">
              📱 Logs are device-specific and clear when you close the browser
            </div>
          </div>
        `;
        logsStats.innerHTML = '';
        logsPagination.style.display = 'none';
      } else {
        // Generate logs stats
        const totalFiles = deviceUploadLogs.length;
        const totalSizeBytes = deviceUploadLogs.reduce((sum, log) => {
          const sizeMB = parseFloat(log.size?.replace(/[^\d.-]/g, '') || '0');
          return sum + sizeMB;
        }, 0);
        const sessionStartTime = deviceUploadLogs[deviceUploadLogs.length - 1]?.timestamp;
        const sessionEndTime = deviceUploadLogs[0]?.timestamp;
        
        logsStats.innerHTML = `
          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 1rem;">
            <div><strong>📊 Total Entries:</strong> ${totalFiles}</div>
            <div><strong>💾 Total Data:</strong> ${totalSizeBytes.toFixed(1)} MB</div>
            <div><strong>📱 Device Session:</strong> ${getCurrentDeviceId().substring(0, 8)}...</div>
            <div><strong>⏰ Session Started:</strong> ${sessionStartTime || 'Unknown'}</div>
          </div>
        `;
        
        // Display logs with pagination (grouped by batch)
        displayDeviceLogsWithPagination(deviceUploadLogs, logsContent, logsPagination);
        
        console.log('📊 Device logs populated in modal:', deviceUploadLogs.length, 'entries');
      }
        
    } catch (error) {
        console.error('Error loading device logs:', error);
        logsContent.innerHTML = `
          <div style="text-align: center; color: #dc3545; padding: 2rem;">
            <div style="font-size: 2rem; margin-bottom: 1rem;">❌</div>
            <div>Failed to load device logs</div>
            <div style="font-size: 0.9rem; margin-top: 0.5rem;">${error.message}</div>
          </div>
        `;
        logsStats.innerHTML = '';
    }
  }
  
  // 📱 Device-Specific Session Management for Upload History with Real Device Names
  function getCurrentDeviceId() {
    let deviceId = sessionStorage.getItem('lanvan_device_id');
    if (!deviceId) {
      // Try to get actual device information
      const deviceInfo = getDeviceInfo();
      const timestamp = Date.now();
      const randomId = Math.random().toString(36).substring(2, 8);
      
      // Create readable device ID with actual device name if available
      deviceId = `${deviceInfo.name}_${timestamp}_${randomId}`;
      sessionStorage.setItem('lanvan_device_id', deviceId);
      
      console.log(`📱 New device session created: ${deviceInfo.displayName}`);
    }
    return deviceId;
  }

  function getDeviceInfo() {
    // Try multiple methods to get device name
    let deviceName = 'Unknown_Device';
    let displayName = 'Unknown Device';
    
    try {
      // Method 1: Try to get hostname if available (some browsers)
      if (typeof window.clientInformation !== 'undefined' && window.clientInformation.platform) {
        const platform = window.clientInformation.platform;
        deviceName = platform.replace(/\s+/g, '_');
      }
      
      // Method 2: Use navigator userAgent to detect device type
      const userAgent = navigator.userAgent;
      const browserInfo = getBrowserInfo(userAgent);
      
      // Method 3: Try to detect common device patterns
      if (userAgent.includes('Windows')) {
        if (userAgent.includes('Windows NT 10')) deviceName = 'Windows_PC';
        else if (userAgent.includes('Windows NT 6')) deviceName = 'Windows_Legacy';
        displayName = deviceName.replace('_', ' ');
      } else if (userAgent.includes('Mac')) {
        if (userAgent.includes('iPhone')) {
          deviceName = 'iPhone';
          displayName = 'iPhone';
        } else if (userAgent.includes('iPad')) {
          deviceName = 'iPad'; 
          displayName = 'iPad';
        } else {
          deviceName = 'Mac';
          displayName = 'Mac';
        }
      } else if (userAgent.includes('Android')) {
        deviceName = 'Android_Device';
        displayName = 'Android Device';
      } else if (userAgent.includes('Linux')) {
        deviceName = 'Linux_PC';
        displayName = 'Linux PC';
      }
      
      // Add browser info to make it more specific
      deviceName = `${deviceName}_${browserInfo.name}`;
      displayName = `${displayName} (${browserInfo.name})`;
      
    } catch (error) {
      console.log('Could not detect device info, using fallback');
      deviceName = 'Unknown_Device';
      displayName = 'Unknown Device';
    }
    
    return {
      name: deviceName,
      displayName: displayName
    };
  }

  function getDeviceUploadHistory() {
    try {
      const deviceId = getCurrentDeviceId();
      const sessionKey = `uploadHistory_${deviceId}`;
      const deviceHistory = JSON.parse(sessionStorage.getItem(sessionKey) || '[]');
      return deviceHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)); // Newest first
    } catch (e) {
      console.log('⚠️ Failed to load device upload history:', e);
      return [];
    }
  }

  function saveToDeviceUploadHistory(stats) {
    try {
      const deviceId = getCurrentDeviceId();
      const sessionKey = `uploadHistory_${deviceId}`;
      const deviceHistory = getDeviceUploadHistory();
      
      // Add device/session info to stats
      const enhancedStats = {
        ...stats,
        deviceId: deviceId,
        sessionTimestamp: Date.now()
      };
      
      deviceHistory.unshift(enhancedStats); // Add to beginning (newest first)
      
      // Keep unlimited history for this session (no limit since it's session-specific)
      // Session will auto-clear when browser closes
      
      sessionStorage.setItem(sessionKey, JSON.stringify(deviceHistory));
      console.log(`📱 Saved to device history (${deviceId}):`, stats.type, stats.size, stats.time);
    } catch (e) {
      console.log('⚠️ Failed to save to device upload history:', e);
    }
  }

  function displayDeviceLogsWithPagination(logs, contentElement, paginationElement) {
    const itemsPerPage = 10;
    
    // Sort logs by timestamp (newest first) for individual file display
    const sortedLogs = logs.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    const totalPages = Math.ceil(sortedLogs.length / itemsPerPage);
    let currentPage = 1;
    
    function renderPage(page) {
      const startIndex = (page - 1) * itemsPerPage;
      const endIndex = startIndex + itemsPerPage;
      const pageItems = sortedLogs.slice(startIndex, endIndex);
      
      let historyHTML = '';
      pageItems.forEach((log, index) => {
        const globalIndex = startIndex + index;
        const isEven = globalIndex % 2 === 0;
        
        // Individual file display only - no batch grouping
        historyHTML += renderSingleUpload(log, isEven);
      });
      
      contentElement.innerHTML = historyHTML;
    }
    
    function renderPagination() {
      if (totalPages <= 1) {
        paginationElement.style.display = 'none';
        return;
      }
      
      paginationElement.style.display = 'block';
      let paginationHTML = `
        <div style="display: flex; justify-content: center; align-items: center; gap: 0.5rem; margin-top: 1rem;">
          <button onclick="uploadHistoryPagination.goToPage(${currentPage - 1})" 
                  ${currentPage === 1 ? 'disabled' : ''} 
                  class="pagination-button"
                  style="padding: 0.4rem 0.8rem; border: 1px solid var(--border-color); background: var(--section-bg); border-radius: 4px; cursor: ${currentPage === 1 ? 'not-allowed' : 'pointer'}; color: var(--text-color) !important;">
            ◀ Prev
          </button>
          <span style="padding: 0.4rem 1rem; color: var(--text-color) !important; opacity: 0.8;">
            Page ${currentPage} of ${totalPages} (${logs.length} total uploads)
          </span>
          <button onclick="uploadHistoryPagination.goToPage(${currentPage + 1})" 
                  ${currentPage === totalPages ? 'disabled' : ''} 
                  class="pagination-button"
                  style="padding: 0.4rem 0.8rem; border: 1px solid var(--border-color); background: var(--section-bg); border-radius: 4px; cursor: ${currentPage === totalPages ? 'not-allowed' : 'pointer'}; color: var(--text-color) !important;">
            Next ▶
          </button>
        </div>
      `;
      
      paginationElement.innerHTML = paginationHTML;
    }
    
    // Create global pagination controller
    window.uploadHistoryPagination = {
      goToPage: function(page) {
        if (page >= 1 && page <= totalPages) {
          currentPage = page;
          renderPage(currentPage);
          renderPagination();
        }
      }
    };
    
    // Initial render
    renderPage(currentPage);
    renderPagination();
  }

  // 📊 Helper functions for enhanced upload history display
  function groupLogsByBatch(logs) {
    const grouped = [];
    const batchGroups = {};
    const processedFiles = new Set(); // Track which files have been processed
    
    // First pass: Create batch groups and collect batch files
    logs.forEach(log => {
      if (log.type === 'Batch Upload Complete' && log.batchId) {
        // Create batch group
        if (!batchGroups[log.batchId]) {
          batchGroups[log.batchId] = {
            isBatch: true,
            batchLog: log,
            individualFiles: []
          };
        }
      }
    });
    
    // Second pass: Assign individual files to their batches
    logs.forEach(log => {
      if (log.batchId && batchGroups[log.batchId] && log.type !== 'Batch Upload Complete') {
        // This is an individual file that belongs to a batch
        batchGroups[log.batchId].individualFiles.push(log);
        processedFiles.add(log.timestamp + log.filename); // Mark as processed
      }
    });
    
    // Third pass: Add standalone uploads (not part of any batch)
    logs.forEach(log => {
      const fileKey = log.timestamp + log.filename;
      if (!log.batchId && !processedFiles.has(fileKey) && log.type !== 'Batch Upload Complete') {
        // This is a standalone single upload
        grouped.push({ isBatch: false, log: log });
      }
    });
    
    // Add batch groups to main array
    Object.values(batchGroups).forEach(batchGroup => {
      // Enhance batch with detailed file information
      const batchFiles = batchGroup.individualFiles;
      const enhancedBatchLog = {
        ...batchGroup.batchLog,
        detailedFiles: batchFiles.map(file => ({
          name: file.filename || 'Unknown',
          size: file.size || 'Unknown',
          speed: file.speed || 'Unknown',
          time: file.time || 'Unknown',
          chunked: file.chunksUsed || false,
          chunks: file.chunkCount || file.chunks || 0,
          protocol: file.protocol || 'Unknown',
          encrypted: file.encrypted || false,
          extension: file.fileExtension || 'unknown'
        }))
      };
      
      grouped.push({
        isBatch: true,
        batchLog: enhancedBatchLog,
        individualFiles: batchFiles
      });
    });
    
    // Sort by timestamp (newest first)
    return grouped.sort((a, b) => {
      const aTime = a.isBatch ? a.batchLog.timestampISO : a.log.timestampISO;
      const bTime = b.isBatch ? b.batchLog.timestampISO : b.log.timestampISO;
      return new Date(bTime) - new Date(aTime);
    });
  }

  function renderBatchUpload(batchGroup, isEven) {
    const batch = batchGroup.batchLog;
    const detailedFiles = batch.detailedFiles || [];
    
    return `
      <div style="background: ${isEven ? 'var(--section-bg)' : 'var(--input-bg)'}; padding: 1rem; margin-bottom: 0.5rem; border-radius: 6px; border: 1px solid var(--border-color); border-left: 4px solid #4a90e2;">
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.8rem;">
          <div style="font-weight: bold; color: var(--text-color); flex: 1;">
            📦 ${batch.filename} 
            <span style="font-weight: normal; color: var(--text-color); opacity: 0.7; font-size: 0.9rem;">(${batch.fileTypes || 'Mixed types'})</span>
          </div>
          <div style="color: var(--text-color); opacity: 0.7; font-size: 0.85rem;">${batch.timestamp}</div>
        </div>
        
        <!-- Batch Summary Stats -->
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 0.5rem; font-size: 0.9rem; margin-bottom: 1rem; background: var(--input-bg); padding: 0.8rem; border-radius: 4px;">
          <div><strong>📊 Total Size:</strong> ${batch.size}</div>
          <div><strong>⚡ Speed:</strong> ${batch.speed}</div>
          <div><strong>⏱️ Time:</strong> ${batch.time}</div>
          <div><strong>🌐 Protocol:</strong> ${batch.protocol}</div>
          <div><strong>📁 Files:</strong> ${batch.filesCount}</div>
          <div><strong>📦 Chunked:</strong> ${batch.filesChunked || 0}</div>
          <div><strong>📏 Avg Size:</strong> ${batch.avgFileSize || 'Unknown'}</div>
        </div>
        
        <!-- Individual Files in Batch (Always Visible with Detailed Stats) -->
        <div style="margin-top: 1rem;">
          <div style="font-weight: bold; color: #333; margin-bottom: 0.8rem; border-bottom: 1px solid #dee2e6; padding-bottom: 0.5rem;">
            📋 Files in this Batch (${detailedFiles.length})
          </div>
          <div style="margin-left: 1rem;">
            ${detailedFiles.map((file, index) => `
              <div style="background: var(--input-bg); padding: 0.8rem; margin: 0.4rem 0; border-radius: 4px; border-left: 3px solid var(--settings-bg);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem;">
                  <div style="font-weight: bold; color: var(--text-color);">
                    ${file.name} <span style="font-size: 0.8rem; color: var(--text-color); opacity: 0.7;">.${file.extension}</span>
                  </div>
                  <div style="font-size: 0.8rem; color: var(--text-color); opacity: 0.7;">#${index + 1}</div>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 0.4rem; font-size: 0.85rem; color: var(--text-color);">
                  <div><strong>📊 Size:</strong> ${file.size}</div>
                  <div><strong>⚡ Speed:</strong> ${file.speed}</div>
                  <div><strong>⏱️ Time:</strong> ${file.time}</div>
                  <div><strong>🌐 Protocol:</strong> ${file.protocol}</div>
                  <div><strong>⏸️ Pauses:</strong> ${file.paused ? `<span style="color: #ffc107;">${file.pauseCount}x</span>` : '<span style="color: #28a745;">None</span>'}</div>
                  <div><strong>📦 Chunks:</strong> ${file.chunked ? `<span style="color: #17a2b8;">${file.chunks}</span>` : '<span style="color: var(--text-color); opacity: 0.7;">Direct</span>'}</div>
                  <div><strong>🔒 Encrypted:</strong> ${file.encrypted ? '<span style="color: #dc3545;">Yes</span>' : '<span style="color: var(--text-color); opacity: 0.7;">No</span>'}</div>
                </div>
              </div>
            `).join('')}
          </div>
        </div>
      </div>
    `;
  }

  function renderSingleUpload(log, isEven) {
    const chunkInfo = log.chunksUsed ? `<span style="color: #0056b3 !important;">📦 ${log.chunkCount || log.chunks || 'Unknown'} chunks</span>` : '<span style="color: var(--text-color) !important; opacity: 0.7;">📄 Direct</span>';
    
    return `
      <div style="background: ${isEven ? 'var(--section-bg)' : 'var(--input-bg)'}; padding: 1rem; margin-bottom: 0.5rem; border-radius: 6px; border: 1px solid var(--border-color);">
        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 0.5rem;">
          <div style="font-weight: bold; color: var(--text-color) !important; flex: 1;">
            ${log.filename || 'Unknown File'}
            <span style="font-size: 0.8rem; color: var(--text-color) !important; opacity: 0.7; margin-left: 0.5rem;">.${log.fileExtension || 'unknown'}</span>
          </div>
          <div style="color: var(--text-color) !important; opacity: 0.7; font-size: 0.85rem;">${log.timestamp || 'Unknown Date'}</div>
        </div>
        
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 0.5rem; font-size: 0.9rem; color: var(--text-color) !important;">
          <div><strong>📊 Size:</strong> ${log.size || 'Unknown'}</div>
          <div><strong>⚡ Speed:</strong> ${log.speed || 'Unknown'}</div>
          <div><strong>⏱️ Time:</strong> ${log.time || 'Unknown'}</div>
          <div><strong>🌐 Protocol:</strong> ${log.protocol || 'Unknown'}</div>
          <div><strong>🔧 Method:</strong> ${log.method || 'Unknown'}</div>
          <div><strong>📦 Chunks:</strong> ${chunkInfo}</div>
          ${log.encrypted ? '<div><strong>🔒 Encrypted:</strong> <span style="color: #dc3545 !important;">Yes</span></div>' : '<div><strong>🔒 Encrypted:</strong> <span style="color: var(--text-color) !important; opacity: 0.7;">No</span></div>'}
        </div>
      </div>
    `;
  }

  // Toggle function for batch file details
  window.toggleBatchFiles = function(batchId) {
    const element = document.getElementById(`batch-files-${batchId}`);
    const button = element.previousElementSibling;
    
    if (element.style.display === 'none') {
      element.style.display = 'block';
      button.textContent = button.textContent.replace('Show', 'Hide');
    } else {
      element.style.display = 'none';
      button.textContent = button.textContent.replace('Hide', 'Show');
    }
  };

  function downloadDeviceLogs() {
    try {
      const deviceUploadLogs = getDeviceUploadHistory();
      
      if (deviceUploadLogs.length === 0) {
        showToast('❌ No device logs to download', 3000);
        return;
      }
      
      const deviceId = getCurrentDeviceId();
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const filename = `lanvan-device-logs-${deviceId.substring(0, 8)}-${timestamp}.txt`;
      
      // Generate comprehensive text report
      let reportContent = `LANVAN DEVICE LOGS REPORT
========================================
Generated: ${new Date().toLocaleString()}
Device Session ID: ${deviceId}
Total Entries: ${deviceUploadLogs.length}
Report Format: Plain Text

`;
      
      // Calculate enhanced summary statistics - only individual file uploads
      const totalFiles = deviceUploadLogs.filter(log => log.type.includes('File Upload')).length;
      const singleUploads = deviceUploadLogs.filter(log => log.type === 'Single File Upload').length;
      const chunkedUploads = deviceUploadLogs.filter(log => log.type === 'Chunked File Upload').length;
      const httpsUploads = deviceUploadLogs.filter(log => log.protocol === 'HTTPS').length;
      const totalSizeBytes = deviceUploadLogs.filter(log => log.type.includes('File Upload')).reduce((sum, log) => {
        const sizeMB = parseFloat(log.size?.replace(/[^\d.-]/g, '') || '0');
        return sum + sizeMB;
      }, 0);
      const fileUploadLogs = deviceUploadLogs.filter(log => log.type.includes('File Upload'));
      const sessionStart = fileUploadLogs[fileUploadLogs.length - 1]?.startTime || fileUploadLogs[fileUploadLogs.length - 1]?.timestamp;
      const sessionEnd = fileUploadLogs[0]?.endTime || fileUploadLogs[0]?.timestamp;
      
      reportContent += `SESSION SUMMARY
========================================
Total Upload Entries: ${totalFiles}
- Single File Uploads: ${singleUploads}
- Chunked Uploads: ${chunkedUploads}
- HTTPS Uploads: ${httpsUploads} (${totalFiles > 0 ? ((httpsUploads/totalFiles)*100).toFixed(1) : 0}%)

Total Data Transferred: ${totalSizeBytes.toFixed(2)} MB
Session Started: ${sessionStart || 'Unknown'}
Last Upload: ${sessionEnd || 'Unknown'}
Average Entry Size: ${totalFiles > 0 ? (totalSizeBytes / totalFiles).toFixed(2) : 0} MB
Security: ${httpsUploads > (totalFiles/2) ? 'Mostly Secure (HTTPS)' : 'Mixed HTTP/HTTPS'}

`;
      
      reportContent += `DETAILED UPLOAD LOG
========================================

`;
      
      // Add each individual file upload entry with enhanced details
      deviceUploadLogs.filter(log => log.type.includes('File Upload')).forEach((log, index) => {
        reportContent += `[${index + 1}] ${log.filename || 'Unknown File'}
    Upload Start: ${log.startTime || log.timestamp || 'Unknown'}
    Upload End: ${log.endTime || 'Unknown'}
    Duration: ${log.time || 'Unknown'} (${log.timeSeconds || 'Unknown'}s)
    File Size: ${log.size || 'Unknown'} (${log.sizeBytes || 'Unknown'} bytes)
    Transfer Speed: ${log.speed || 'Unknown'} (${log.speedMBps || 'Unknown'} MB/s)
    Upload Type: ${log.chunksUsed ? 'Chunked' : 'Direct'}
    Chunk Count: ${log.chunkCount || 0}
    Chunk Size: ${log.chunkSize || 'N/A'}
    Protocol: ${log.protocol || 'Unknown'}
    Method: ${log.method || 'Unknown'}
    ${log.encrypted ? 'Encryption: AES-256-CBC' : 'Encryption: No'}
    File Extension: .${log.fileExtension || 'unknown'}
    Network Condition: ${log.networkCondition || 'Unknown'}
    Transfer Efficiency: ${log.transferEfficiency || 'Unknown'}
    
    Advanced Stats:
    - Resume Count: ${log.resumeCount || 0}
    - Supports Resume: ${log.supportsResume ? 'Yes' : 'No'}
    - Upload ID: ${log.uploadId || 'Unknown'}
    - Session ID: ${log.sessionId || 'Unknown'}
    - Upload Method: ${log.uploadMethod || 'Unknown'}
    - Average Chunk Time: ${log.avgChunkTime || 'N/A'}

`;
      });
      
      reportContent += `
========================================
End of Report - Generated by Lanvan File Transfer System
Device Session will reset when browser is closed
========================================`;
      
      // Create and download the file
      const blob = new Blob([reportContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showToast(`📄 Device logs downloaded: ${filename}`, 4000);
      
    } catch (error) {
      console.error('Error downloading device logs:', error);
      showToast('❌ Failed to download device logs', 3000);
    }
  }

  function clearDeviceLogs() {
    try {
      const deviceId = getCurrentDeviceId();
      const sessionKey = `uploadHistory_${deviceId}`;
      const currentHistory = getDeviceUploadHistory();
      
      if (currentHistory.length === 0) {
        showToast('📊 No device logs to clear', 2000);
        return;
      }
      
      // Confirm before clearing
      if (!confirm(`Are you sure you want to clear all ${currentHistory.length} device log entries?\n\nThis action cannot be undone.`)) {
        return;
      }
      
      // Clear the device-specific history
      sessionStorage.removeItem(sessionKey);
      
      // Force refresh the logs display
      const logsSection = document.getElementById('deviceLogsSection');
      const logsContent = document.getElementById('deviceLogsContent');
      const logsStats = document.getElementById('deviceLogsStats');
      const logsPagination = document.getElementById('deviceLogsPagination');
      
      if (logsSection && logsSection.style.display !== 'none') {
        // Immediately update the content to show empty state
        if (logsContent) {
          logsContent.innerHTML = `
            <div style="text-align: center; color: var(--text-color); opacity: 0.6; padding: 2rem;">
              <div style="font-size: 3rem; margin-bottom: 1rem;">🧹</div>
              <div style="font-size: 1.1rem;">Device logs cleared successfully</div>
              <div style="font-size: 0.9rem; margin-top: 0.5rem;">Upload some files to see new activity logs here</div>
              <div style="font-size: 0.85rem; margin-top: 1rem; color: #999;">
                📱 Logs are device-specific and clear when you close the browser
              </div>
            </div>
          `;
        }
        
        // Clear stats
        if (logsStats) {
          logsStats.innerHTML = '';
        }
        
        // Hide pagination
        if (logsPagination) {
          logsPagination.style.display = 'none';
        }
      }
      
      showToast(`🧹 Successfully cleared ${currentHistory.length} device log entries for this session`, 3000);
      
    } catch (error) {
      console.error('Error clearing device logs:', error);
      showToast('❌ Failed to clear device logs', 3000);
    }
  }

  function updateUploadManager() {
    const countElement = document.getElementById('uploadCount');
    const uploadQueue_element = document.getElementById('uploadQueue');
    
    const activeUploads = uploadQueue.filter(item => 
      ['queued', 'uploading'].includes(item.status)
    ).length;
    
    const completedUploads = uploadQueue.filter(item => 
      ['completed', 'cancelled', 'error'].includes(item.status)
    ).length;
    
    const currentlyUploading = uploadQueue.filter(item => item.status === 'uploading').length;
    
    if (countElement) {
      // Show both active count and completed info
      const concurrencyInfo = currentlyUploading > 1 ? ` • ${currentlyUploading}/${currentMaxConcurrent} concurrent` : '';
      const completedInfo = completedUploads > 0 ? ` • ${completedUploads} completed` : '';
      countElement.textContent = `(${activeUploads}${concurrencyInfo}${completedInfo})`;
    }

    // Keep upload manager visible when there are ANY items (active or completed)
    const uploadManager = document.getElementById('uploadManager');
    if (uploadManager && uploadQueue.length > 0) {
      uploadManager.style.display = 'block';
      
      // 🔄 Re-sort and re-render upload items in proper order
      sortAndRenderUploadQueue();
    }
    // Users can manually use the logs to check completed uploads
    // The upload manager will stay visible so users can see their upload progress
  }

  // 🔄 Sort and re-render upload queue with proper priority order
  function sortAndRenderUploadQueue() {
    const queue = document.getElementById('uploadQueue');
    if (!queue) return;
    
    // Sort upload queue: uploading > queued > completed > error > cancelled
    const sortedQueue = [...uploadQueue].sort((a, b) => {
      const statusPriority = {
        'uploading': 1,
        'queued': 2,
        'completed': 3,
        'error': 4,
        'cancelled': 5
      };
      
      const aPriority = statusPriority[a.status] || 999;
      const bPriority = statusPriority[b.status] || 999;
      
      if (aPriority !== bPriority) {
        return aPriority - bPriority;
      }
      
      // Within same status, sort by creation time (newest first for active, oldest first for completed)
      if (['uploading', 'queued'].includes(a.status)) {
        return b.uploadId - a.uploadId; // Newer active uploads first
      } else {
        return a.uploadId - b.uploadId; // Older completed uploads first
      }
    });
    
    // Clear existing items and re-render in sorted order
    queue.innerHTML = '';
    sortedQueue.forEach(uploadItem => {
      renderUploadItemElement(uploadItem);
    });
  }

  function renderUploadItem(uploadItem) {
    // Just add to queue, sorting will be handled by updateUploadManager
    renderUploadItemElement(uploadItem);
  }

  function renderUploadItemElement(uploadItem) {
    const queue = document.getElementById('uploadQueue');
    if (!queue) return;

    // Remove existing item if it exists
    const existingItem = document.getElementById(`upload-${uploadItem.id}`);
    if (existingItem) {
      existingItem.remove();
    }

    const itemDiv = document.createElement('div');
    itemDiv.className = `upload-item ${uploadItem.status}`; // Use consistent format that matches CSS
    itemDiv.id = `upload-${uploadItem.id}`;
    
    itemDiv.innerHTML = `
      <div class="upload-file-info">
        <div class="upload-file-name">${escapeHtml(uploadItem.fileName)}</div>
        <div class="upload-file-details">
          <span>${formatFileSize(uploadItem.fileSize)}</span>
          <span id="speed-${uploadItem.id}">${getStatusDisplay(uploadItem.status)}</span>
          <span id="remaining-${uploadItem.id}"></span>
        </div>
      </div>
      <div class="upload-progress-section">
        <div class="upload-progress-bar">
          <div class="upload-progress-fill" id="progress-fill-${uploadItem.id}" style="width: ${uploadItem.progress || 0}%"></div>
        </div>
        <div class="upload-progress-text">
          <span id="progress-text-${uploadItem.id}">${Math.round(uploadItem.progress || 0)}%</span>
          <span id="status-${uploadItem.id}">${getStatusDisplay(uploadItem.status)}</span>
        </div>
      </div>
      <div class="upload-controls">
        ${getControlButtons(uploadItem)}
      </div>
    `;
    
    queue.appendChild(itemDiv);
  }

  // 📊 Smart insertion based on upload priority
  function insertUploadItemInOrder(queue, newItemDiv, newUploadItem) {
    const existingItems = Array.from(queue.children);
    let inserted = false;
    
    for (let i = 0; i < existingItems.length; i++) {
      const existingItem = existingItems[i];
      const existingId = parseInt(existingItem.id.replace('upload-', ''));
      const existingUploadItem = uploadQueue.find(item => item.id === existingId);
      
      if (existingUploadItem && shouldInsertBefore(newUploadItem, existingUploadItem)) {
        queue.insertBefore(newItemDiv, existingItem);
        inserted = true;
        break;
      }
    }
    
    if (!inserted) {
      queue.appendChild(newItemDiv);
    }
  }

  // 📊 Determine if new item should be inserted before existing item
  // 🎨 UI UPDATE OPTIMIZATION: Minimal throttling for responsive feel
  let lastUIUpdate = {};
  const UI_UPDATE_THROTTLE = 50; // ms - reduced from 100ms for ultra-responsive feel

  function updateUploadItem(uploadItem, forceUpdate = false) {
    const now = Date.now();
    const lastUpdate = lastUIUpdate[uploadItem.id] || 0;
    
    // Throttle UI updates to prevent flickering, except for important state changes
    const isImportantUpdate = 
      uploadItem.status === 'uploading' || 
      uploadItem.status === 'cancelled' || 
      uploadItem.status === 'error' ||
      uploadItem.status === 'processing' ||
      uploadItem.progress === 100;
    
    // Use requestIdleCallback for non-critical updates to prevent blocking
    // But NEVER throttle progress updates for actively uploading files OR force updates
    const isActiveUpload = uploadItem.status === 'uploading' && uploadItem.progress < 100;
    
    // Safety net can force updates bypassing ALL throttling
    if (!forceUpdate && !isImportantUpdate && !isActiveUpload && (now - lastUpdate) < UI_UPDATE_THROTTLE) {
      return; // Skip this update to prevent flickering
    }
    
    // For processing updates, only defer the status text update UNLESS it's a force update
    if (uploadItem.status === 'processing' && !forceUpdate) {
      console.log(`⚙️ Processing update for ${uploadItem.fileName}`);
      // Only defer status updates for processing files, allow progress updates to flow normally
      if (window.requestIdleCallback) {
        requestIdleCallback(() => {
          // Only update status-related elements, not progress
          const statusText = document.getElementById(`status-${uploadItem.id}`);
          if (statusText && statusText.textContent !== '⚙️ Processing...') {
            statusText.textContent = '⚙️ Processing...';
          }
        });
      }
      // Continue to immediate UI update for progress and other elements
    }
    
    performUIUpdate(uploadItem, forceUpdate);
  }

  // Separated UI update logic to allow async processing
  function performUIUpdate(uploadItem, forceUpdate = false) {
    const now = Date.now();
    lastUIUpdate[uploadItem.id] = now;

    const progressFill = document.getElementById(`progress-fill-${uploadItem.id}`);
    const progressText = document.getElementById(`progress-text-${uploadItem.id}`);
    const statusText = document.getElementById(`status-${uploadItem.id}`);
    const speedText = document.getElementById(`speed-${uploadItem.id}`);
    const remainingText = document.getElementById(`remaining-${uploadItem.id}`);
    const itemDiv = document.getElementById(`upload-${uploadItem.id}`);

    if (!itemDiv) return;

    // 🎨 SMOOTH PROGRESS: Use immediate updates for forced updates, requestAnimationFrame for normal ones
    if (progressFill && uploadItem.progress !== undefined) {
      if (forceUpdate) {
        // Immediate update for safety net - no animation delay
        progressFill.style.width = `${uploadItem.progress}%`;
      } else {
        // Smooth animation for normal updates
        requestAnimationFrame(() => {
          progressFill.style.width = `${uploadItem.progress}%`;
        });
      }
    }

    // Update progress text with stable rounding
    if (progressText) {
      const displayProgress = Math.round(uploadItem.progress * 10) / 10; // One decimal place
      progressText.textContent = `${displayProgress}%`;
    }

    // 🚀 STABLE STATUS: Update status with anti-flicker logic
    if (statusText) {
      let statusDisplay = uploadItem.status.charAt(0).toUpperCase() + uploadItem.status.slice(1);
      
      // Special handling for status displays
      if (uploadItem.status === 'cancelled') {
        statusDisplay = '❌ Cancelled';
      } else if (uploadItem.status === 'processing') {
        statusDisplay = '⚙️ Processing...';
      }
      
      // Only update if text actually changed to prevent unnecessary redraws
      if (statusText.textContent !== statusDisplay) {
        statusText.textContent = statusDisplay;
      }
    }

    // 📊 SMOOTH SPEED: Stable speed display with minimal flicker
    if (speedText && uploadItem.status === 'uploading') {
      const newSpeedText = `${formatSpeed(uploadItem.speed)}`;
      if (speedText.textContent !== newSpeedText) {
        speedText.textContent = newSpeedText;
      }
    } else if (speedText && uploadItem.status === 'cancelled') {
      speedText.textContent = 'Cancelled';
    } else if (speedText && uploadItem.status === 'processing') {
      speedText.textContent = 'Server processing';
    }

    // ⏱️ STABLE TIME: Update time remaining with debouncing
    if (remainingText && uploadItem.timeRemaining > 0 && uploadItem.status === 'uploading') {
      const newTimeText = `${formatTime(uploadItem.timeRemaining)} left`;
      if (remainingText.textContent !== newTimeText) {
        remainingText.textContent = newTimeText;
      }
    } else if (remainingText && uploadItem.status === 'cancelled') {
      remainingText.textContent = '';
    }

    // Update cancel button state for cancelled, completed, and processing items
    const cancelBtn = document.querySelector(`#upload-${uploadItem.id} .upload-control-btn.cancel`);
    if (cancelBtn) {
      if (uploadItem.status === 'cancelled' || uploadItem.status === 'completed' || uploadItem.status === 'processing') {
        cancelBtn.style.display = 'none'; // Hide cancel button for cancelled, completed, and processing items
        console.log(`🔄 Cancel button hidden for ${uploadItem.fileName} (status: ${uploadItem.status})`);
      } else {
        cancelBtn.style.display = 'inline-block'; // Show cancel button for active uploads
      }
    }

    // Update item styling based on status (only if changed)
    const newClassName = `upload-item ${uploadItem.status}`;
    if (itemDiv.className !== newClassName) {
      itemDiv.className = newClassName;
    }
  }

  function cancelUpload(uploadId) {
    const uploadItem = uploadQueue.find(item => item.id === uploadId);
    if (!uploadItem) return;

    // Abort the upload if in progress
    if (uploadItem.xhr) {
      uploadItem.xhr.abort();
    }

    // Set status to cancelled and update UI to show red mark IMMEDIATELY
    uploadItem.status = 'cancelled';
    uploadItem.error = 'Cancelled by user';
    
    // Force immediate UI update to show cancel status
    updateUploadItem(uploadItem);
    
    // Also force update the progress text and button visibility with immediate styling
    const statusText = document.getElementById(`status-${uploadItem.id}`);
    const speedText = document.getElementById(`speed-${uploadItem.id}`);
    const remainingText = document.getElementById(`remaining-${uploadItem.id}`);
    const cancelBtn = document.querySelector(`#upload-${uploadItem.id} .upload-control-btn.cancel`);
    const itemDiv = document.getElementById(`upload-${uploadItem.id}`);
    
    if (statusText) statusText.textContent = '❌ Cancelled';
    if (speedText) speedText.textContent = 'Cancelled';
    if (remainingText) remainingText.textContent = '';
    if (cancelBtn) cancelBtn.style.display = 'none';
    
    // Force immediate red styling application
    if (itemDiv) {
      itemDiv.className = 'upload-item cancelled';
      // Force CSS update by triggering reflow
      itemDiv.offsetHeight;
    }
    
    // Keep the current progress - don't reset it to show how much was uploaded
    console.log(`❌ Upload cancelled: ${uploadItem.fileName} at ${uploadItem.progress.toFixed(1)}%`);
    
    // 📊 Log cancelled upload with detailed stats
    const cancelledStats = {
      type: 'Cancelled Upload',
      filename: uploadItem.fileName,
      size: `${(uploadItem.file.size / (1024 * 1024)).toFixed(1)} MB`,
      sizeBytes: uploadItem.file.size,
      progress: `${uploadItem.progress.toFixed(1)}%`,
      uploadedBytes: uploadItem.uploadedBytes || 0,
      cancelledAt: new Date().toLocaleString(),
      cancelledAtISO: new Date().toISOString(),
      reason: 'Cancelled by user',
      timestamp: new Date().toLocaleString(),
      timestampISO: new Date().toISOString(),
      protocol: window.location.protocol === 'https:' ? 'HTTPS' : 'HTTP',
      method: 'Upload Cancelled',
      encrypted: uploadItem.isAESEnabled || false,
      uploadId: uploadItem.id,
      sessionId: getCurrentDeviceId(),
      fileExtension: uploadItem.fileName.split('.').pop()?.toLowerCase() || 'unknown',
      uploadMethod: uploadItem.totalChunks ? 'Chunked (Cancelled)' : 'Direct (Cancelled)',
      supportsResume: uploadItem.totalChunks ? true : false,
      status: 'cancelled'
    };
    saveStatsToLog(cancelledStats);
    
    // End this upload and start the next one immediately
    endUpload();
    
    // Start the next upload in queue (if any)
    setTimeout(() => {
      startNextUpload();
    }, 100);
    
    // 🔍 Check if we should show clear button after cancellation
    // Check if all uploads are now finished (no more active uploads)
    const hasActiveUploads = uploadQueue.some(item => 
      item.status === 'uploading' || item.status === 'queued'
    );
    
    if (!hasActiveUploads) {
      // All uploads finished (including this cancellation) - show clear button
      showClearCompletedButton();
      updateUploadManager(); // Update the display to show completed/cancelled count
    }
    
    // DON'T remove from queue - keep it visible with red mark until user clears manually
  }

  function cancelAllUploads() {
    const itemsBeingCancelled = uploadQueue.filter(item => 
      ['queued', 'uploading'].includes(item.status)
    );
    
    console.log(`❌ Cancelling ${itemsBeingCancelled.length} active uploads...`);
    
    uploadQueue.forEach(item => {
      if (['queued', 'uploading'].includes(item.status)) {
        cancelUpload(item.id);
      }
    });
    
    // After all cancellations, ensure clear button is shown
    // Use a slight delay to ensure all individual cancel operations complete
    setTimeout(() => {
      const hasActiveUploads = uploadQueue.some(item => 
        item.status === 'uploading' || item.status === 'queued'
      );
      
      if (!hasActiveUploads) {
        showClearCompletedButton();
        updateUploadManager();
        console.log(`✅ All ${itemsBeingCancelled.length} uploads cancelled - clear button shown`);
      }
    }, 200);
  }

  function showClearCompletedButton() {
    // Check if there are any completed or cancelled items to clear
    const completedItems = uploadQueue.filter(item => 
      ['completed', 'cancelled', 'error'].includes(item.status)
    );
    
    if (completedItems.length === 0) return;
    
    // Check if clear button already exists
    let clearBtn = document.getElementById('clearCompletedBtn');
    if (clearBtn) {
      clearBtn.style.display = 'inline-block';
      return;
    }
    
    // Create clear button
    const buttonContainer = document.querySelector('#uploadManager .upload-manager-btn').parentElement;
    clearBtn = document.createElement('button');
    clearBtn.id = 'clearCompletedBtn';
    clearBtn.className = 'upload-manager-btn';
    clearBtn.style.background = 'var(--settings-bg)';
    clearBtn.style.marginLeft = '0.5rem';
    clearBtn.textContent = '🧹 Clear All';
    clearBtn.title = 'Clear all completed, cancelled, and failed uploads';
    clearBtn.onclick = clearCompletedUploads;
    
    buttonContainer.appendChild(clearBtn);
  }

  function clearCompletedUploads() {
    // Remove completed, cancelled, and error items from DOM and queue
    const itemsToRemove = uploadQueue.filter(item => 
      ['completed', 'cancelled', 'error'].includes(item.status)
    );
    
    itemsToRemove.forEach(item => {
      const itemDiv = document.getElementById(`upload-${item.id}`);
      if (itemDiv) {
        itemDiv.remove();
      }
    });
    
    // Filter out completed items from queue
    uploadQueue = uploadQueue.filter(item => 
      !['completed', 'cancelled', 'error'].includes(item.status)
    );
    
    // Hide clear button if no more items to clear
    const clearBtn = document.getElementById('clearCompletedBtn');
    if (clearBtn && uploadQueue.filter(item => ['completed', 'cancelled', 'error'].includes(item.status)).length === 0) {
      clearBtn.style.display = 'none';
    }
    
    updateUploadManager();
    
    // NOW refresh the file list since user manually cleared
    setTimeout(() => {
      refreshFileList();
    }, 500);
    
    console.log(`🧹 Cleared ${itemsToRemove.length} completed uploads`);
  }

  function removeCompletedUpload(itemId) {
    // Find the upload item in queue
    const item = uploadQueue.find(upload => upload.id === itemId);
    if (!item) {
      console.warn(`❌ Upload item ${itemId} not found in queue`);
      return;
    }

    // Only allow removal of completed, cancelled, or error items
    if (!['completed', 'cancelled', 'error'].includes(item.status)) {
      console.warn(`❌ Cannot remove upload ${itemId} with status: ${item.status}`);
      return;
    }

    // Remove from DOM
    const itemDiv = document.getElementById(`upload-${itemId}`);
    if (itemDiv) {
      itemDiv.remove();
    }

    // Remove from queue
    uploadQueue = uploadQueue.filter(upload => upload.id !== itemId);

    // Update the upload manager display
    updateUploadManager();

    console.log(`🗑️ Removed completed upload: ${item.file ? item.file.name : item.text || 'clipboard item'}`);

    // If this was the last completed item, hide the clear all button
    const clearBtn = document.getElementById('clearCompletedBtn');
    if (clearBtn && uploadQueue.filter(item => ['completed', 'cancelled', 'error'].includes(item.status)).length === 0) {
      clearBtn.style.display = 'none';
    }

    // Refresh file list if we removed a completed file upload
    if (item.status === 'completed' && item.file) {
      setTimeout(() => {
        refreshFileList();
      }, 500);
    }
  }

  function startNextUpload() {
    // Protect against interfering with active uploads
    if (uploadQueue.length === 0) {
      console.log('📤 Upload queue is empty');
      return;
    }
    
    // Find all queued items that can be uploaded
    const queuedItems = uploadQueue.filter(item => item.status === 'queued');
    
    if (queuedItems.length === 0) {
      console.log('📤 No queued uploads found');
      return;
    }
    
    // Smart concurrent upload: Start multiple uploads if optimal
    const availableSlots = currentMaxConcurrent - activeUploads;
    const itemsToStart = Math.min(availableSlots, queuedItems.length);
    
    if (itemsToStart <= 0) {
      console.log(`📤 Cannot start upload: ${activeUploads}/${currentMaxConcurrent} uploads active`);
      return;
    }
    
    // 📊 Enhanced prioritization: Incomplete/In-Progress uploads first, then queued
    const prioritizedItems = queuedItems.sort((a, b) => {
      // Priority 1: Incomplete/Failed uploads first (resume priority)
      const aIncomplete = a.status === 'failed' || a.status === 'paused';
      const bIncomplete = b.status === 'failed' || b.status === 'paused';
      
      if (aIncomplete && !bIncomplete) return -1;
      if (!aIncomplete && bIncomplete) return 1;
      
      // Priority 2: AES files get priority within same completion status
      const aHasAES = a.isAESEnabled;
      const bHasAES = b.isAESEnabled;
      
      if (aHasAES && !bHasAES) return -1;
      if (!aHasAES && bHasAES) return 1;
      
      // Priority 3: Sort by file size (smaller files first for better throughput)
      return a.fileSize - b.fileSize;
    });
    
    // Start multiple uploads concurrently
    for (let i = 0; i < itemsToStart; i++) {
      const uploadItem = prioritizedItems[i];
      console.log(`📤 Starting concurrent upload ${i + 1}/${itemsToStart}: ${uploadItem.file.name} (Queue: ${uploadQueue.length} items)`);
      startUploadWithManager(uploadItem);
    }
    
    // Show feedback for concurrent uploads
    if (itemsToStart > 1) {
      const isAESMixed = prioritizedItems.slice(0, itemsToStart).some(item => item.isAESEnabled);
      const aesNote = isAESMixed ? ' (AES files prioritized)' : '';
      showToast(`🚀 Starting ${itemsToStart} concurrent uploads${aesNote}`, 3000);
    }
  }

  function startUploadWithManager(uploadItem) {
    uploadItem.status = 'uploading';
    
    // Initialize upload timing and progress
    uploadItem.startTime = Date.now();
    uploadItem.progress = 0;
    uploadItem.uploadedBytes = 0;
    
    updateUploadItem(uploadItem);
    
    startUpload();
    
    // Use the existing upload logic but with progress tracking
    uploadSingleFileWithProgress(uploadItem);
  }

  function uploadSingleFileWithProgress(uploadItem) {
    const formData = new FormData();
    formData.append('files', uploadItem.file);
    
    const isAESEnabled = isEncryptionEnabled && document.getElementById('enableEncryption').checked;
    formData.append('encrypt', isAESEnabled.toString());

    const xhr = new XMLHttpRequest();
    uploadItem.xhr = xhr;

    // Track upload progress with simple speed calculation
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const progress = (e.loaded / e.total) * 100;
        
        const elapsed = (Date.now() - uploadItem.startTime) / 1000;
        const speed = e.loaded / elapsed; // bytes per second
        const remaining = speed > 0 ? (e.total - e.loaded) / speed : 0;

        uploadItem.progress = progress;
        uploadItem.lastProgressUpdate = Date.now(); // Track for safety net
        
        // Start safety net for active uploads
        startProgressUpdateSafetyNet();
        uploadItem.uploadedBytes = e.loaded;
        uploadItem.speed = speed;
        uploadItem.timeRemaining = remaining;

        // When upload reaches 100%, immediately show processing for larger files
        if (progress >= 100) {
          const fileSizeMB = uploadItem.file.size / (1024 * 1024);
          if (fileSizeMB > 10) {
            uploadItem.status = 'processing';
            console.log(`⚙️ Upload complete - Setting ${uploadItem.fileName} to processing status immediately`);
            const statusText = document.getElementById(`status-${uploadItem.id}`);
            const speedText = document.getElementById(`speed-${uploadItem.id}`);
            if (statusText) statusText.textContent = '⚙️ Processing...';
            if (speedText) speedText.textContent = 'Server processing';
          }
        }

        // Update network speed tracking for smart concurrency (sample during upload)
        if (elapsed > 2 && progress > 10 && progress < 90) { // Sample mid-upload for accuracy
          const speedMBps = (e.loaded / (1024 * 1024)) / elapsed;
          if (speedMBps > 0.1) { // Only track meaningful speeds
            updateNetworkSpeed(speedMBps);
          }
        }

        updateUploadItem(uploadItem);
      }
    });

    xhr.addEventListener('load', () => {
      if (xhr.status === 200) {
        // Show processing status for files > 10MB (if not already set)
        const fileSizeMB = uploadItem.file.size / (1024 * 1024);
        if (fileSizeMB > 10 && uploadItem.status !== 'processing') {
          uploadItem.status = 'processing';
          console.log(`⚙️ Setting ${uploadItem.fileName} to processing status`);
          const statusText = document.getElementById(`status-${uploadItem.id}`);
          const speedText = document.getElementById(`speed-${uploadItem.id}`);
          if (statusText) statusText.textContent = '⚙️ Processing...';
          if (speedText) speedText.textContent = 'Server processing';
          updateUploadItem(uploadItem);
        }
        
        // Show toast for processing (only if processing)
        if (uploadItem.status === 'processing') {
          showToast(`⚙️ Processing ${uploadItem.file.name} on server... (${fileSizeMB.toFixed(1)} MB)`, 3000);
          
          // Show processing for a moment before marking complete
          setTimeout(() => {
            uploadItem.status = 'completed';
            uploadItem.progress = 100;
            updateUploadItem(uploadItem);
            updateUploadManager(); // Update manager to show completed count
          }, 1500); // 1.5 second processing indicator
        } else {
          uploadItem.status = 'completed';
          uploadItem.progress = 100;
          updateUploadItem(uploadItem);
          updateUploadManager(); // Update manager to show completed count
        }
        
        endUpload();
        
        // 📊 Track network speed for adaptive concurrency
        const fileSize = (uploadItem.file.size / (1024 * 1024)).toFixed(1);
        const uploadTime = ((Date.now() - uploadItem.startTime) / 1000).toFixed(1);
        const avgSpeed = (fileSize / uploadTime).toFixed(1);
        const speedMBps = parseFloat(avgSpeed);
        
        // Update network speed tracking for smart concurrency
        updateNetworkSpeed(speedMBps);
        
        // 🔔 Show toast notification for individual file completion with smart refresh detection
        const currentFileCount = document.querySelectorAll('.file-card').length;
        showToast(`✅ ${uploadItem.file.name} uploaded successfully (${fileSize} MB in ${uploadTime}s @ ${avgSpeed} MB/s)`, 4000);
        
        // Files will auto-load via the auto-refresh system, no manual intervention needed
        
        // 📊 Save individual upload stats to history with enhanced metadata
        const uploadStats = {
          type: 'Single File Upload',
          filename: uploadItem.file.name,
          size: `${fileSize} MB`,
          sizeBytes: uploadItem.file.size,
          time: `${uploadTime}s`,
          timeSeconds: parseFloat(uploadTime),
          speed: `${avgSpeed} MB/s`,
          speedMBps: parseFloat(avgSpeed),
          timestamp: new Date().toLocaleString(),
          timestampISO: new Date().toISOString(),
          startTime: new Date(uploadItem.startTime).toLocaleString(),
          endTime: new Date().toLocaleString(),
          startTimeISO: new Date(uploadItem.startTime).toISOString(),
          endTimeISO: new Date().toISOString(),
          protocol: window.location.protocol === 'https:' ? 'HTTPS' : 'HTTP',
          method: 'Direct Upload',
          encrypted: isAESEnabled && document.getElementById('enableEncryption').checked,
          // Enhanced stats
          chunksUsed: false,
          chunkCount: 0,
          chunkSize: 'N/A',
          uploadId: uploadItem.id,
          sessionId: getCurrentDeviceId(),
          fileExtension: uploadItem.fileName.split('.').pop()?.toLowerCase() || 'unknown',
          uploadMethod: 'Direct (Single Request)',
          supportsResume: false,
          resumeCount: 0,
          transferEfficiency: '100%', // Direct uploads are 100% efficient
          networkCondition: uploadItem.speed > (5 * 1024 * 1024) ? 'Fast' : uploadItem.speed > (1 * 1024 * 1024) ? 'Medium' : 'Slow',
          status: 'completed' // Add status field for successful uploads
        };
        saveStatsToLog(uploadStats);
        
        // DON'T auto-refresh file list - let uploads stay visible until user clears them
        // Only refresh when ALL uploads are complete or user manually clears
        
        // Check if all uploads are complete before updating file list
        const hasActiveUploads = uploadQueue.some(item => 
          item.status === 'uploading' || item.status === 'queued'
        );
        
        if (!hasActiveUploads) {
          // All uploads complete - show clear button but DON'T auto-refresh files
          showClearCompletedButton();
          
          // � Refresh file count immediately to show new total
          setTimeout(() => {
            refreshFileCountOnly();
          }, 100); // Small delay to ensure server has processed all files
          
          // �🔔 Show final completion toast for all uploads without creating batch log entry
          // Only count successfully completed uploads (exclude cancelled, error, etc.)
          const completedUploads = uploadQueue.filter(item => item.status === 'completed');
          const totalFiles = completedUploads.length;
          
          if (totalFiles > 0) {
            const totalSize = completedUploads.reduce((sum, item) => sum + item.file.size, 0);
            const totalSizeMB = (totalSize / (1024 * 1024)).toFixed(1);
            const sessionTime = ((Date.now() - Math.min(...completedUploads.map(item => item.startTime))) / 1000).toFixed(1);
            const sessionSpeed = (totalSizeMB / sessionTime).toFixed(1);
            
            // Only show completion toast with smart refresh detection - individual files are already logged separately
            const currentFileCount = document.querySelectorAll('.file-card').length;
            showToast(`🎉 All ${totalFiles} files uploaded successfully! (${totalSizeMB} MB total in ${sessionTime}s @ ${sessionSpeed} MB/s)`, 6000);
            
            // Files will auto-load via the auto-refresh system, no manual intervention needed
          }
        }
        
        // Don't auto-remove completed items - let user control with clear button
        // Check if all uploads are finished to show clear button
        const allUploadsFinished = uploadQueue.some(item => 
          item.status === 'uploading' || item.status === 'queued'
        );
        
        if (!allUploadsFinished) {
          // All uploads complete - show clear button
          showClearCompletedButton();
          updateUploadManager(); // Update the display to show completed count
        }
      } else {
        uploadItem.status = 'error';
        uploadItem.error = `Upload failed: ${xhr.status}`;
        updateUploadItem(uploadItem);
        endUpload();
        
        // 🔔 Show toast notification for upload error
        showToast(`❌ Upload failed: ${uploadItem.file.name} (Error ${xhr.status})`, 5000);
        
        // 📊 Log failed upload with detailed stats
        const failedStats = {
          type: 'Failed Upload',
          filename: uploadItem.fileName,
          size: `${(uploadItem.file.size / (1024 * 1024)).toFixed(1)} MB`,
          sizeBytes: uploadItem.file.size,
          progress: `${uploadItem.progress.toFixed(1)}%`,
          uploadedBytes: uploadItem.uploadedBytes || 0,
          failedAt: new Date().toLocaleString(),
          failedAtISO: new Date().toISOString(),
          errorCode: xhr.status,
          errorMessage: `HTTP ${xhr.status}`,
          reason: 'Server error',
          timestamp: new Date().toLocaleString(),
          timestampISO: new Date().toISOString(),
          startTime: new Date(uploadItem.startTime).toLocaleString(),
          startTimeISO: new Date(uploadItem.startTime).toISOString(),
          protocol: window.location.protocol === 'https:' ? 'HTTPS' : 'HTTP',
          method: 'Upload Failed',
          encrypted: uploadItem.isAESEnabled || false,
          uploadId: uploadItem.id,
          sessionId: getCurrentDeviceId(),
          fileExtension: uploadItem.fileName.split('.').pop()?.toLowerCase() || 'unknown',
          uploadMethod: uploadItem.totalChunks ? 'Chunked (Failed)' : 'Direct (Failed)',
          supportsResume: uploadItem.totalChunks ? true : false,
          status: 'failed' // Add status field for failed uploads
        };
        saveStatsToLog(failedStats);
        
        // Check if all uploads are complete (including failed ones)
        const allUploadsFinished = uploadQueue.some(item => 
          item.status === 'uploading' || item.status === 'queued'
        );
        
        if (!allUploadsFinished) {
          // All uploads complete - DON'T auto-refresh, let uploads stay visible until cleared
          // Only show clear button for user control
          showClearCompletedButton();
          
          // 🔔 Show completion summary even with errors
          const successfulUploads = uploadQueue.filter(item => item.status === 'completed').length;
          const failedUploads = uploadQueue.filter(item => item.status === 'error').length;
          if (successfulUploads > 0) {
            showToast(`📊 Upload session complete: ${successfulUploads} successful, ${failedUploads} failed`, 6000);
          }
        }
      }
      
      // Start next upload in queue
      startNextUpload();
    });

    xhr.addEventListener('error', () => {
      uploadItem.status = 'error';
      uploadItem.error = 'Network error';
      updateUploadItem(uploadItem);
      endUpload();
      
      // 📊 Log network error upload with detailed stats
      const networkErrorStats = {
        type: 'Network Error Upload',
        filename: uploadItem.fileName,
        size: `${(uploadItem.file.size / (1024 * 1024)).toFixed(1)} MB`,
        sizeBytes: uploadItem.file.size,
        progress: `${uploadItem.progress.toFixed(1)}%`,
        uploadedBytes: uploadItem.uploadedBytes || 0,
        failedAt: new Date().toLocaleString(),
        failedAtISO: new Date().toISOString(),
        errorCode: 'NETWORK_ERROR',
        errorMessage: 'Network connection failed',
        reason: 'Network error',
        timestamp: new Date().toLocaleString(),
        timestampISO: new Date().toISOString(),
        startTime: new Date(uploadItem.startTime).toLocaleString(),
        startTimeISO: new Date(uploadItem.startTime).toISOString(),
        protocol: window.location.protocol === 'https:' ? 'HTTPS' : 'HTTP',
        method: 'Upload Network Error',
        encrypted: uploadItem.isAESEnabled || false,
        uploadId: uploadItem.id,
        sessionId: getCurrentDeviceId(),
        fileExtension: uploadItem.fileName.split('.').pop()?.toLowerCase() || 'unknown',
        uploadMethod: uploadItem.totalChunks ? 'Chunked (Network Error)' : 'Direct (Network Error)',
        supportsResume: uploadItem.totalChunks ? true : false,
        status: 'network_error' // Add status field for network error uploads
      };
      saveStatsToLog(networkErrorStats);
      
      // Check if all uploads are complete
      const hasActiveUploads = uploadQueue.some(item => 
        item.status === 'uploading' || item.status === 'queued'
      );
      
      if (!hasActiveUploads) {
        // All uploads complete - DON'T auto-refresh, let uploads stay visible until cleared
        showClearCompletedButton();
      }
      
      startNextUpload();
    });

    xhr.addEventListener('abort', () => {
      if (uploadItem.status !== 'paused') {
        uploadItem.status = 'cancelled';
        updateUploadItem(uploadItem);
        endUpload();
      }
    });

    xhr.open('POST', '/upload-auto');
    xhr.send(formData);
  }

  // 🚀 Enhanced Chunked Upload with Server-Side Adaptive Optimization
  async function uploadLargeFileChunked(uploadItem) {
    const file = uploadItem.file;
    
    try {
      // 🎯 Get optimal chunk size from server based on file size and system capabilities
      console.log(`🔍 Getting optimal chunk size for ${file.size} byte file...`);
      const chunkResponse = await fetch(`/api/upload/chunk-size/${file.size}`);
      const chunkData = await chunkResponse.json();
      
      let CHUNK_SIZE = 1024 * 1024; // Default 1MB fallback
      
      if (chunkData.status === 'success') {
        CHUNK_SIZE = chunkData.optimal_chunk_size;
        console.log(`🎯 Server recommends ${chunkData.chunk_size_mb}MB chunks for this ${chunkData.system_info.platform} system`);
        
        // Show optimization info to user
        if (chunkData.recommendations.use_concurrent_uploads) {
          showToast(`🚀 Large file detected! Using ${chunkData.chunk_size_mb}MB chunks optimized for ${chunkData.system_info.platform}`, 4000);
        }
      } else {
        console.warn('⚠️ Could not get optimal chunk size, using default 1MB');
        showToast('⚠️ Using default chunk size - server optimization unavailable', 2000);
      }
      
      const totalChunks = Math.ceil(file.size / CHUNK_SIZE);
    
      uploadItem.totalChunks = totalChunks;
      uploadItem.uploadedChunks = 0;
      uploadItem.status = 'uploading';
      uploadItem.currentChunkIndex = 0;
      uploadItem.adaptiveChunkSize = CHUNK_SIZE;
      uploadItem.systemOptimized = chunkData.status === 'success';
      
      log.debug(`Starting adaptive chunked upload: ${totalChunks} chunks of ${(CHUNK_SIZE/1024/1024).toFixed(2)}MB each`);
      
      // Upload chunks sequentially
      for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
        // Update current chunk index
        uploadItem.currentChunkIndex = chunkIndex;
        
        // Check if upload was cancelled before starting each chunk
        if (uploadItem.status === 'cancelled') {
          console.log(`❌ Upload cancelled at chunk ${chunkIndex + 1}`);
          return;
        }
        
        const start = chunkIndex * CHUNK_SIZE;
        const end = Math.min(start + CHUNK_SIZE, file.size);
        const chunk = file.slice(start, end);
        
        // Create form data for chunk
        const formData = new FormData();
        formData.append('chunk', chunk);
        formData.append('filename', file.name);
        formData.append('part_number', (chunkIndex + 1).toString());
        formData.append('total_parts', totalChunks.toString());
        
        // Upload chunk with XMLHttpRequest for progress tracking
        const success = await uploadChunkWithProgress(uploadItem, formData, chunkIndex, totalChunks);
        
        // Check again if paused during the chunk upload
        if (uploadItem.status === 'paused') {
          console.log(`⏸️ Upload paused during chunk ${chunkIndex + 1} upload`);
          return;
        }
        
        if (!success) {
          // Only set error if not paused/cancelled
          if (uploadItem.status === 'uploading') {
            uploadItem.status = 'error';
            uploadItem.error = `Failed to upload chunk ${chunkIndex + 1}`;
            updateUploadItem(uploadItem);
            showToast(`❌ Chunk upload failed: ${uploadItem.fileName} (chunk ${chunkIndex + 1})`, 5000);
          }
          return;
        }
        
        uploadItem.uploadedChunks = chunkIndex + 1;
        
        // Update progress based on chunks uploaded with accurate speed calculation
        const progress = ((chunkIndex + 1) / totalChunks) * 100;
        uploadItem.progress = progress;
        uploadItem.lastProgressUpdate = Date.now(); // Track for safety net
        uploadItem.uploadedBytes = Math.min(end, file.size);
        
        // Start safety net for active uploads
        startProgressUpdateSafetyNet();
        
        // 📊 Calculate speed for chunked uploads using adjusted timing
        const effectiveStartTime = uploadItem.resumeAdjustedStartTime || uploadItem.startTime;
        const elapsed = (Date.now() - effectiveStartTime) / 1000;
        if (elapsed > 0) {
          uploadItem.speed = uploadItem.uploadedBytes / elapsed; // bytes per second (excludes paused time)
          uploadItem.timeRemaining = uploadItem.speed > 0 ? (file.size - uploadItem.uploadedBytes) / uploadItem.speed : 0;
        }
        
        updateUploadItem(uploadItem);
      }
      
      // All chunks uploaded, finalize the file (only if not paused/cancelled)
      if (uploadItem.status === 'uploading') {
        await finalizeChunkedUpload(uploadItem);
      }
      
    } catch (error) {
      // Only handle errors if not paused (pausing can cause AbortError)
      if (uploadItem.status !== 'paused' && uploadItem.status !== 'cancelled') {
        uploadItem.status = 'error';
        uploadItem.error = `Chunked upload failed: ${error.message}`;
        updateUploadItem(uploadItem);
        showToast(`❌ Chunked upload failed: ${uploadItem.fileName}`, 5000);
      }
    }
  }

  // Upload individual chunk with progress tracking
  function uploadChunkWithProgress(uploadItem, formData, chunkIndex, totalChunks) {
    return new Promise((resolve) => {
      const xhr = new XMLHttpRequest();
      
      // Store xhr for potential cancellation - use unique key for chunked uploads
      uploadItem.xhr = xhr;
      uploadItem.currentXhr = xhr; // Keep separate reference for chunked uploads
      
      xhr.addEventListener('load', () => {
        if (xhr.status === 200) {
          console.log(`✅ Chunk ${chunkIndex + 1}/${totalChunks} uploaded successfully`);
          resolve(true);
        } else {
          console.log(`❌ Chunk ${chunkIndex + 1}/${totalChunks} failed: ${xhr.status}`);
          resolve(false);
        }
      });
      
      xhr.addEventListener('error', () => {
        console.log(`❌ Chunk ${chunkIndex + 1}/${totalChunks} error`);
        resolve(false);
      });
      
      xhr.addEventListener('abort', () => {
        console.log(`⏸️ Chunk ${chunkIndex + 1}/${totalChunks} aborted`);
        // For aborts (pause), don't treat as failure
        resolve(false);
      });
      
      xhr.open('POST', '/upload_chunk');
      xhr.send(formData);
    });
  }

  // Finalize chunked upload
  async function finalizeChunkedUpload(uploadItem) {
    const formData = new FormData();
    formData.append('filename', uploadItem.file.name);
    formData.append('total_parts', uploadItem.totalChunks.toString());
    formData.append('encrypt', 'false'); // Chunked uploads don't support encryption
    
    return new Promise((resolve, reject) => {
      const xhr = new XMLHttpRequest();
      
      xhr.addEventListener('load', () => {
        if (xhr.status === 200) {
          const response = JSON.parse(xhr.responseText);
          
          // Check if streaming assembly was used
          const isStreamingAssembly = response.streaming_assembly || false;
          const assemblyMethod = response.assembly_method || 'traditional chunk combination';
          
          // Show appropriate processing status
          uploadItem.status = 'processing';
          const statusText = document.getElementById(`status-${uploadItem.id}`);
          const speedText = document.getElementById(`speed-${uploadItem.id}`);
          
          if (isStreamingAssembly) {
            if (statusText) statusText.textContent = '🌊 Streaming assembly completed';
            if (speedText) speedText.textContent = 'Optimized processing';
            // Streaming is much faster, show completion sooner
            uploadItem.status = 'completed';
            uploadItem.progress = 100;
            updateUploadItem(uploadItem);
            
            const fileSizeMB = (uploadItem.file.size / (1024 * 1024)).toFixed(1);
            showToast(`🌊 Streaming upload completed for ${uploadItem.fileName} (${fileSizeMB} MB) - 4x faster!`, 3000);
          } else {
            if (statusText) statusText.textContent = '⚙️ Processing chunks...';
            if (speedText) speedText.textContent = 'Server processing';
            
            const fileSizeMB = (uploadItem.file.size / (1024 * 1024)).toFixed(1);
            showToast(`⚙️ Processing ${uploadItem.totalChunks} chunks for ${uploadItem.fileName}... (${fileSizeMB} MB) - Other operations may continue`, 4000);
            
            // Traditional processing takes longer
            const processAsync = () => {
              uploadItem.status = 'completed';
              uploadItem.progress = 100;
              updateUploadItem(uploadItem);
            };
            
            if (window.requestIdleCallback) {
              requestIdleCallback(() => {
                setTimeout(processAsync, 2000);
              }, { timeout: 5000 });
            } else {
              setTimeout(processAsync, 2000);
            }
          }
          
          updateUploadItem(uploadItem);
          endUpload();
          
          // Show completion toast with smart refresh detection
          const fileSize = (uploadItem.file.size / (1024 * 1024)).toFixed(1);
          const uploadTime = ((Date.now() - uploadItem.startTime) / 1000).toFixed(1);
          const currentFileCount = document.querySelectorAll('.file-card').length;
          showToast(`✅ ${uploadItem.fileName} uploaded successfully via chunked upload (${fileSize} MB, ${uploadItem.totalChunks} chunks)`, 5000);
          
          // Files will auto-load via the auto-refresh system, no manual intervention needed
          
          // Save enhanced chunked upload stats
          const uploadStats = {
            type: 'Chunked File Upload',
            filename: uploadItem.fileName,
            size: `${fileSize} MB`,
            sizeBytes: uploadItem.file.size,
            time: `${uploadTime}s`,
            timeSeconds: parseFloat(uploadTime),
            speed: `${(parseFloat(fileSize) / parseFloat(uploadTime)).toFixed(1)} MB/s`,
            speedMBps: parseFloat(fileSize) / parseFloat(uploadTime),
            timestamp: new Date().toLocaleString(),
            timestampISO: new Date().toISOString(),
            startTime: new Date(uploadItem.startTime).toLocaleString(),
            endTime: new Date().toLocaleString(),
            startTimeISO: new Date(uploadItem.startTime).toISOString(),
            endTimeISO: new Date().toISOString(),
            protocol: window.location.protocol === 'https:' ? 'HTTPS' : 'HTTP',
            method: 'Chunked Upload (Resume Capable)',
            encrypted: false, // Chunked uploads don't support encryption yet
            // Enhanced chunked stats with adaptive optimization info
            chunksUsed: true,
            chunkCount: uploadItem.totalChunks,
            chunkSize: uploadItem.systemOptimized ? `${(uploadItem.adaptiveChunkSize/1024/1024).toFixed(1)} MB (Adaptive)` : '1 MB (Fallback)',
            systemOptimized: uploadItem.systemOptimized || false,
            adaptiveChunkSize: uploadItem.adaptiveChunkSize || (1024 * 1024),
            resumeCount: uploadItem.resumeCount || 0,
            uploadId: uploadItem.id,
            sessionId: getCurrentDeviceId(),
            fileExtension: uploadItem.fileName.split('.').pop()?.toLowerCase() || 'unknown',
            uploadMethod: 'Chunked (Large File)',
            supportsResume: true,
            transferEfficiency: uploadItem.resumeCount > 0 ? `${(100 - (uploadItem.resumeCount * 5)).toFixed(1)}%` : '100%',
            networkCondition: uploadItem.speed > (3 * 1024 * 1024) ? 'Fast' : uploadItem.speed > (1 * 1024 * 1024) ? 'Medium' : 'Slow',
            chunkFailures: 0, // TODO: Track chunk failures
            avgChunkTime: `${(parseFloat(uploadTime) / uploadItem.totalChunks).toFixed(2)}s`,
            status: 'completed' // Add status field for successful chunked uploads
          };
          saveStatsToLog(uploadStats);
          
          // Don't auto-refresh file list, let clear button handle it
          // Check if all uploads are finished to show clear button
          const allUploadsComplete = !uploadQueue.some(item => 
            item.status === 'uploading' || item.status === 'queued'
          );
          
          if (allUploadsComplete) {
            // All uploads complete - DON'T auto-refresh, just show clear button
            showClearCompletedButton();
            
            // Unblock QR generation after all chunked uploads complete
            window._qrBlocked = false;
            
            // 🔄 Refresh file count immediately to show new total
            setTimeout(() => {
              refreshFileCountOnly();
            }, 100); // Small delay to ensure server has processed all files
          }
          
          resolve(true);
        } else {
          // Unblock QR generation on chunked upload error
          window._qrBlocked = false;
          reject(new Error(`Finalization failed: ${xhr.status}`));
        }
      });
      
      xhr.addEventListener('error', () => {
        // Unblock QR generation on chunked upload network error
        window._qrBlocked = false;
        reject(new Error('Finalization network error'));
      });
      
      xhr.open('POST', '/finalize_upload');
      xhr.send(formData);
    });
  }

  // Dynamic file list refresh function
  async function refreshFileList() {
    try {
      console.log('🔄 Refreshing file list...');
      
      const response = await fetch('/api/files');
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      
      const data = await response.json();
      updateFileDisplay(data.files);
      
      console.log(`✅ File list updated: ${data.files.length} files`);
    } catch (error) {
      console.error('❌ Failed to refresh file list:', error);
      // Fallback to page reload if API fails
      setTimeout(() => {
        location.reload();
      }, 1000);
    }
  }

  // 🔄 Manual refresh with user feedback
  async function refreshFileListManually() {
    showToast('🔄 Refreshing file list...', 2000);
    
    try {
      await refreshFileList();
      showToast('✅ File list refreshed successfully!', 3000);
    } catch (error) {
      console.error('❌ Manual refresh failed:', error);
      showToast('❌ Refresh failed - reloading page...', 3000);
      setTimeout(() => location.reload(), 1000);
    }
  }

  // 🔄 Auto-refresh functionality for cross-device sync
  let autoRefreshInterval;
  let lastFileCount = 0;
  let autoRefreshActive = true;
  let currentActiveSection = 'file'; // Track which section is currently active

  function startAutoRefresh() {
    console.log('🔄 Starting auto-refresh for cross-device file sync...');
    
    // Initial file count setup
    const fileGrid = document.querySelector('.file-grid');
    if (fileGrid) {
      lastFileCount = fileGrid.querySelectorAll('.file-card').length;
    }
    
    // Immediate file count refresh to ensure accuracy
    refreshFileCountOnly();
    
    // Set up polling every 5 seconds to check for file changes
    autoRefreshInterval = setInterval(async () => {
      if (!autoRefreshActive) return;
      
      // Only refresh files when file section is active, not when in clipboard mode
      if (currentActiveSection !== 'file') {
        console.log('🔄 Skipping file refresh - clipboard section is active');
        return;
      }
      
      try {
        const response = await fetch('/api/files');
        if (!response.ok) return;
        
        const data = await response.json();
        const currentFileCount = data.files.length;
        
        // Only update if file count changed (indicating new uploads/deletions)
        if (currentFileCount !== lastFileCount) {
          console.log(`🔄 File count changed: ${lastFileCount} → ${currentFileCount}, auto-loading...`);
          updateFileDisplay(data.files);
          
          // Silently auto-load new files without showing toast notifications
          if (currentFileCount > lastFileCount) {
            console.log(`📁 ${currentFileCount - lastFileCount} new file(s) auto-loaded from other device(s)`);
          } else if (currentFileCount < lastFileCount) {
            console.log(`📁 ${lastFileCount - currentFileCount} file(s) removed from other device(s)`);
          }
          
          // lastFileCount is updated inside updateFileDisplay now
        } else {
          // Even if file count is same, ensure display is current (files might have changed)
          updateFileCount(currentFileCount);
        }
      } catch (error) {
        console.error('❌ Auto-refresh failed:', error);
        // Don't spam errors, just log them
      }
    }, 5000); // Check every 5 seconds
  }

  function stopAutoRefresh() {
    autoRefreshActive = false;
    if (autoRefreshInterval) {
      clearInterval(autoRefreshInterval);
      autoRefreshInterval = null;
      console.log('🛑 Auto-refresh stopped');
    }
  }

  function pauseAutoRefresh() {
    autoRefreshActive = false;
    console.log('⏸️ Auto-refresh paused');
  }

  function resumeAutoRefresh() {
    autoRefreshActive = true;
    console.log('▶️ Auto-refresh resumed');
  }

  // Pause auto-refresh when user is actively uploading to avoid conflicts
  function handleUploadStart() {
    pauseAutoRefresh();
  }

  function handleUploadEnd() {
    // Resume auto-refresh after a short delay to allow current upload to complete
    setTimeout(() => {
      resumeAutoRefresh();
    }, 2000);
  }

  // 📊 Dedicated function to update file count display
  function updateFileCount(fileCount) {
    const fileCountEl = document.getElementById('fileCount');
    if (fileCountEl) {
      if (fileCount > 0) {
        fileCountEl.textContent = `(${fileCount} file${fileCount === 1 ? '' : 's'})`;
      } else {
        fileCountEl.textContent = '';
      }
    }
    console.log(`📊 File count updated: ${fileCount} files`);
  }

  // 🔄 Refresh only the file count from server without updating display
  async function refreshFileCountOnly() {
    try {
      const response = await fetch('/api/files');
      if (!response.ok) {
        console.warn(`❌ Failed to refresh file count: HTTP ${response.status}`);
        return;
      }
      
      const data = await response.json();
      updateFileCount(data.files.length);
      lastFileCount = data.files.length; // Keep auto-refresh tracking in sync
      
      console.log(`🔄 File count refreshed: ${data.files.length} files`);
    } catch (error) {
      console.error('❌ Failed to refresh file count:', error);
    }
  }

  function updateFileDisplay(files) {
    const fileGrid = document.querySelector('.file-grid');
    const noFilesMsg = document.querySelector('.no-files-message');
    
    // Update file count using dedicated function
    const fileCount = files ? files.length : 0;
    updateFileCount(fileCount);
    
    // Update lastFileCount for auto-refresh tracking
    lastFileCount = fileCount;
    
    if (!files || files.length === 0) {
      // Show no files message
      if (fileGrid) fileGrid.style.display = 'none';
      if (!noFilesMsg) {
        const container = fileGrid ? fileGrid.parentElement : document.querySelector('.file-section');
        if (container) {
          const msg = document.createElement('div');
          msg.className = 'no-files-message';
          
          // Check if files have been uploaded recently but aren't visible
          // Since we now auto-load files, just show the standard message
          msg.innerHTML = '<p style="text-align: center; color: var(--text-color); opacity: 0.6; font-style: italic;">No files uploaded yet. Drag & drop or click to upload!</p>';
          
          container.appendChild(msg);
        }
      } else {
        // Update existing message - always show standard message since we auto-load
        noFilesMsg.innerHTML = '<p style="text-align: center; color: var(--text-color); opacity: 0.6; font-style: italic;">No files uploaded yet. Drag & drop or click to upload!</p>';
        noFilesMsg.style.display = 'block';
      }
      return;
    }

    // Hide no files message and reset recent uploads flag when files are visible
    if (noFilesMsg) {
      noFilesMsg.style.display = 'none';
    }
    
    // Update or create file grid
    if (!fileGrid) {
      // Create file grid if it doesn't exist - find the section with "Available Files" heading
      let container = null;
      const sections = document.querySelectorAll('section');
      for (const section of sections) {
        const h2 = section.querySelector('h2');
        if (h2 && h2.textContent.includes('Available Files')) {
          container = section;
          break;
        }
      }
      
      // Fallback to any section if specific one not found
      if (!container) {
        container = document.querySelector('section');
      }
      
      if (container) {
        const newGrid = document.createElement('div');
        newGrid.className = 'file-grid';
        container.appendChild(newGrid);
      } else {
        console.warn('❌ Could not find container for file grid');
        return;
      }
    }
    
    const grid = document.querySelector('.file-grid');
    if (grid) {
      grid.style.display = 'grid';
      grid.innerHTML = files.map(file => `
        <div class="file-card">
          <div class="file-icon">📄</div>
          <div class="file-name" title="${escapeHtml(file)}">${escapeHtml(file)}</div>
          <a href="/download/${encodeURIComponent(file)}" download class="download-btn">⬇ Download</a>
        </div>
      `).join('');
    }
  }

  // 🚨 SERVER SHUTDOWN DETECTION
  let shutdownCheckInterval;
  let serverShutdown = false;

  function startServerStatusMonitoring() {
    // Check server status every 2 seconds for faster shutdown detection
    shutdownCheckInterval = setInterval(async () => {
      if (serverShutdown) return; // Don't check if already shut down
      
      try {
        const response = await fetch('/api/server-status', {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (!response.ok || response.status === 503) {
          handleServerShutdown('Server connection lost - server may have been shut down');
          return;
        }
        
        const data = await response.json();
        if (data.shutdown) {
          // Graceful shutdown notification from server
          const shutdownMessage = data.message || 'Server is shutting down gracefully';
          const timeRemaining = data.timeRemaining || 5;
          handleServerShutdown(shutdownMessage, timeRemaining);
        } else if (data.shutdownWarning) {
          // Pre-shutdown warning
          const warningMessage = data.warningMessage || 'Server shutdown initiated - saving your work...';
          const countdown = data.countdown || 10;
          showShutdownWarning(warningMessage, countdown);
        }
      } catch (error) {
        // Network error - likely server is down
        if (!serverShutdown) {
          handleServerShutdown('Server connection failed - server appears to be offline');
        }
      }
    }, 2000); // Check every 2 seconds for faster response
  }

  function showShutdownWarning(message, countdown) {
    // Show warning toast with countdown
    const warningToast = `⚠️ ${message} (${countdown}s)`;
    showToast(warningToast, 0, null, 'warning');
    
    // Update countdown every second
    let remainingTime = countdown;
    const countdownInterval = setInterval(() => {
      remainingTime--;
      if (remainingTime > 0) {
        const updatedWarning = `⚠️ ${message} (${remainingTime}s)`;
        updateToastContent(updatedWarning);
      } else {
        // Show final shutdown message
        clearInterval(countdownInterval);
        updateToastContent('🚨 SERVER IS SHUT DOWN - All operations halted');
        
        // Add final visual indication
        document.body.style.borderTop = '5px solid #dc3545';
        
        console.log('🚨 Server shutdown completed - final message displayed');
      }
    }, 1000);
    
    // Add visual warning indicator
    document.body.style.borderTop = '5px solid #ffc107';
    
    console.log(`⚠️ Shutdown warning: ${message} - ${countdown}s remaining`);
  }

  function handleServerShutdown(reason = 'Server has been shut down', gracefulTime = 0) {
    if (serverShutdown) return; // Prevent multiple notifications
    serverShutdown = true;
    
    // Stop all uploads immediately with proper feedback
    if (uploadQueue.length > 0) {
      uploadQueue.forEach(item => {
        if (item.xhr) item.xhr.abort();
        if (item.currentXhr) item.currentXhr.abort();
        item.status = 'cancelled';
        item.error = 'Server shutdown';
      });
      updateUploadManager();
      console.log(`🚨 ${uploadQueue.length} uploads cancelled due to server shutdown`);
    }
    
    // Clear intervals
    if (shutdownCheckInterval) clearInterval(shutdownCheckInterval);
    if (autoRefreshInterval) clearInterval(autoRefreshInterval);
    
    // Determine shutdown type and message
    let shutdownType = 'SHUTDOWN';
    let messageColor = '#dc3545';
    let overlayColor = 'rgba(220, 53, 69, 0.15)';
    
    if (gracefulTime > 0) {
      shutdownType = 'GRACEFUL SHUTDOWN';
      messageColor = '#ffc107';
      overlayColor = 'rgba(255, 193, 7, 0.15)';
    }
    
    // Show enhanced shutdown notification with device info
    const deviceInfo = `Device: ${navigator.platform} | Browser: ${navigator.userAgent.split(' ').pop()}`;
    showToast(
      `🚨 SERVER ${shutdownType}: ${reason}\n\nAll operations halted. Files in progress have been cancelled.\n\nPlease wait for the server to restart or contact the host device.`,
      0, // Permanent toast
      { shutdownReason: reason, deviceInfo: deviceInfo, timestamp: new Date().toISOString() },
      'error'
    );
    
    // Add enhanced shutdown overlay
    const overlay = document.createElement('div');
    overlay.id = 'shutdownOverlay';
    overlay.style.cssText = `
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: ${overlayColor};
      backdrop-filter: blur(3px);
      z-index: 10000;
      display: flex;
      justify-content: center;
      align-items: center;
      pointer-events: none;
      animation: shutdownFadeIn 1s ease-in;
    `;
    
    // Add shutdown animation
    const style = document.createElement('style');
    style.textContent = `
      @keyframes shutdownFadeIn {
        from { opacity: 0; backdrop-filter: blur(0px); }
        to { opacity: 1; backdrop-filter: blur(3px); }
      }
      @keyframes shutdownPulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.05); }
      }
    `;
    document.head.appendChild(style);
    
    const shutdownMessage = document.createElement('div');
    shutdownMessage.style.cssText = `
      background: ${messageColor};
      color: white;
      padding: 2.5rem;
      border-radius: 15px;
      text-align: center;
      font-size: 1.3rem;
      font-weight: bold;
      box-shadow: 0 8px 32px rgba(0,0,0,0.4);
      max-width: 600px;
      margin: 1rem;
      animation: shutdownPulse 2s ease-in-out infinite;
      border: 3px solid rgba(255,255,255,0.3);
    `;
    
    const currentTime = new Date().toLocaleString();
    shutdownMessage.innerHTML = `
      🚨 SERVER ${shutdownType}<br>
      <div style="font-size: 1rem; margin-top: 1rem; font-weight: normal; line-height: 1.5;">
        <strong>Reason:</strong> ${reason}<br><br>
        <div style="background: rgba(0,0,0,0.2); padding: 1rem; border-radius: 8px; margin: 1rem 0;">
          • All file transfers have been stopped<br>
          • Upload queue has been cleared<br>
          • Server connection lost at ${currentTime}
        </div>
        <div style="font-size: 0.9rem; color: rgba(255,255,255,0.9);">
          Please contact the host device to restart the server<br>
          or wait for automatic restart if configured.
        </div>
      </div>
    `;
    
    overlay.appendChild(shutdownMessage);
    document.body.appendChild(overlay);
    
    // Log detailed shutdown information
    console.error(`🚨 Server shutdown detected:`, {
      reason: reason,
      timestamp: new Date().toISOString(),
      gracefulTime: gracefulTime,
      uploadsActive: uploadQueue.length,
      deviceInfo: navigator.userAgent,
      url: location.href
    });
    
    // Optional: Try to save any pending work to localStorage
    try {
      const shutdownInfo = {
        timestamp: Date.now(),
        reason: reason,
        url: location.href,
        uploadsLost: uploadQueue.length
      };
      localStorage.setItem('lastServerShutdown', JSON.stringify(shutdownInfo));
    } catch (e) {
      console.log('Could not save shutdown info to localStorage');
    }
  }

  // Clear all files function
  async function clearAllFiles() {
    if (!confirm('Are you sure you want to clear all uploaded files?\n\nNote: Files currently being uploaded may need to be cleared again after upload completes.')) {
      return;
    }

    try {
      console.log('🧹 Clearing all files...');
      
      const response = await fetch('/clear', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        }
      });

      if (response.ok) {
        // Update file display immediately
        updateFileDisplay([]);
        showToast('🧹 All files cleared successfully!', 3000);
        console.log('✅ Files cleared successfully');
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (error) {
      console.error('❌ Failed to clear files:', error);
      showToast('❌ Failed to clear files. Please try again.', 5000);
    }
  }

  // Performance Optimization: Cache DOM elements once after DOM is loaded
  let DOM_CACHE = {};
  let dropZone, fileInput, preview, progressBar, statusText; // Legacy variables
  
  // Initialize DOM cache when DOM is ready
  document.addEventListener('DOMContentLoaded', () => {
    // Start server status monitoring immediately
    startServerStatusMonitoring();
    
    // Check if we're on clipboard-only page
    const isClipboardOnly = typeof show_clipboard_only !== 'undefined' && show_clipboard_only;
    
    // Initialize current active section based on default view or URL
    const urlPath = window.location.pathname;
    if (urlPath === '/clipboard' || '{{ default_view }}' === 'clipboard') {
      currentActiveSection = 'clipboard';
    } else {
      currentActiveSection = 'file';
    }
    console.log(`🎯 Initial active section: ${currentActiveSection}`);
    
    DOM_CACHE = {
      // File upload elements (only for file sharing mode)
      dropZone: isClipboardOnly ? null : document.getElementById('drop-zone'),
      fileInput: isClipboardOnly ? null : document.getElementById('fileInput'),
      preview: isClipboardOnly ? null : document.getElementById('file-preview'),
      progressBar: isClipboardOnly ? null : document.getElementById('uploadProgress'),
      statusText: isClipboardOnly ? null : document.getElementById('uploadStatus'),
      
      // Common elements (both modes)
      toast: document.getElementById('toast'),
      toastProgress: document.getElementById('toast-progress'),
      protocolIcon: document.getElementById('protocolIcon'),
      protocolText: document.getElementById('protocolText'),
      protocolStatus: document.getElementById('protocolStatus'),
      aesToggle: document.getElementById('enableEncryption'),
      darkModeToggle: document.getElementById('enableDarkMode')
    };
    
    // Debug DOM cache - check if all elements are found
    if (isClipboardOnly) {
      console.log('🔍 DOM Cache Status (Clipboard Mode):', {
        toast: !!DOM_CACHE.toast,
        protocolIcon: !!DOM_CACHE.protocolIcon,
        protocolText: !!DOM_CACHE.protocolText,
        protocolStatus: !!DOM_CACHE.protocolStatus,
        aesToggle: !!DOM_CACHE.aesToggle,
        darkModeToggle: !!DOM_CACHE.darkModeToggle
      });
    } else {
      console.log('🔍 DOM Cache Status (File Sharing Mode):', {
        dropZone: !!DOM_CACHE.dropZone,
        fileInput: !!DOM_CACHE.fileInput,
        preview: !!DOM_CACHE.preview,
        progressBar: !!DOM_CACHE.progressBar,
        statusText: !!DOM_CACHE.statusText,
        toast: !!DOM_CACHE.toast,
        protocolIcon: !!DOM_CACHE.protocolIcon,
      protocolText: !!DOM_CACHE.protocolText,
      protocolStatus: !!DOM_CACHE.protocolStatus,
      aesToggle: !!DOM_CACHE.aesToggle,
      darkModeToggle: !!DOM_CACHE.darkModeToggle
    });
    
    // Legacy variables for backward compatibility
    dropZone = DOM_CACHE.dropZone;
    fileInput = DOM_CACHE.fileInput;
    preview = DOM_CACHE.preview;
    progressBar = DOM_CACHE.progressBar;
    statusText = DOM_CACHE.statusText;
    
    // Initialize file count display from current page data
    const fileGrid = document.querySelector('.file-grid');
    if (fileGrid) {
      const fileCards = fileGrid.querySelectorAll('.file-card');
      const fileCount = fileCards.length;
      updateFileCount(fileCount);
      lastFileCount = fileCount; // Initialize lastFileCount for auto-refresh tracking
    } else {
      lastFileCount = 0;
    }
    
    // Auto-load clipboard history if clipboard section is available
    const clipboardSection = document.getElementById('clipboardSection');
    if (clipboardSection) {
      console.log('📋 Auto-loading clipboard history on page load...');
      // Delay the refresh slightly to ensure all DOM elements are ready
      setTimeout(() => {
        if (typeof refreshClipboardHistory === 'function') {
          refreshClipboardHistory();
        }
      }, 500);
    }
    
    // Set up event listeners after DOM cache is ready
    setupEventListeners();
    
    // 🔄 Start auto-refresh for file list to sync across devices
    startAutoRefresh();
    
    // 👁️ Pause auto-refresh when page is hidden to save bandwidth
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        pauseAutoRefresh();
      } else {
        resumeAutoRefresh();
        // Force refresh when page becomes visible again
        setTimeout(refreshFileList, 1000);
        // Also refresh file count immediately
        refreshFileCountOnly();
      }
    });

    // ✅ Update Protocol Status Indicator
    const protocolIcon = DOM_CACHE.protocolIcon;
    const protocolText = DOM_CACHE.protocolText;
    const protocolStatus = DOM_CACHE.protocolStatus;
    const isHTTPS = location.protocol === 'https:';
    
    // Find the QR code hint text (the third span in protocolStatus)
    const qrHintText = protocolStatus.querySelector('#qrHintText');
    
    if (isHTTPS) {
      protocolIcon.textContent = '🔒';
      protocolText.textContent = 'HTTPS';
      protocolText.style.color = '#22c55e';
      
      if (qrHintText) {
        qrHintText.innerHTML = 'Tap the WiFi icon above to share this connection securely with other devices.';
      }
    } else {
      protocolIcon.textContent = '🌐';
      protocolText.textContent = 'HTTP';
      protocolText.style.color = '#f59e0b';
      
      if (qrHintText) {
        qrHintText.innerHTML = 'Consider using HTTPS for encrypted file transfers.';
      }
    }
    
    // ✅ Check for mDNS service and update status
    updateMDNSStatus();

    // ✅ Handle AES toggle restrictions - DISABLED FOR HTTP
    if (location.protocol === 'http:') {
    // 🛡️ NEW LOGIC: Allow AES over HTTP with HTTP-Safe mode
    const toggle = DOM_CACHE.aesToggle;
    if (toggle) {
      // Enable AES toggle for HTTP (HTTP-Safe mode will provide security)
      toggle.disabled = false;
      const toggleWrapper = toggle.closest('div');
      toggleWrapper.style.opacity = '1';
      toggleWrapper.title = "�️ AES over HTTP requires HTTP-Safe Mode for complete security protection.";

      // Add change listener
      toggle.addEventListener('change', function() {
        isEncryptionEnabled = this.checked;
        console.log('🔐 Encryption toggled:', isEncryptionEnabled);
        
        // 🛡️ HTTP-Safe mode is now automatic for HTTP connections
        if (location.protocol === 'http:' && this.checked) {
          console.log('🛡️ HTTP-Safe mode automatically enabled for HTTP connection');
          showToast('🛡️ HTTP-Safe mode automatically enabled for secure encryption!', 4000);
        }
      });
    }
    } else {
      // HTTPS - encryption available (same as HTTP now with HTTP-Safe mode)
      const toggle = DOM_CACHE.aesToggle;
      if (toggle) {
        toggle.addEventListener('change', function() {
          isEncryptionEnabled = this.checked;
          console.log('🔐 Encryption toggled:', isEncryptionEnabled);
        });
      }
    }
  }
  });
  
  function setupEventListeners() {
    // Set up clipboard "Add Text" button with high-priority event listener
    const addTextBtn = document.getElementById('addTextToClipboardBtn');
    if (addTextBtn) {
      // Use high-priority event listener that works even during heavy uploads
      addTextBtn.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        // Use setTimeout(0) to ensure this always runs in next event loop
        setTimeout(() => addTextToClipboard(), 0);
      }, { capture: true, passive: false }); // High priority capture event
      console.log('✅ Clipboard Add Text button event listener set up');
    }
    
    // Set up modal clipboard "Add Text" button as well
    const addTextBtnModal = document.getElementById('addTextToClipboardBtnModal');
    if (addTextBtnModal) {
      addTextBtnModal.addEventListener('click', function(e) {
        e.preventDefault();
        e.stopPropagation();
        setTimeout(() => addTextToClipboard(), 0);
      }, { capture: true, passive: false });
      console.log('✅ Modal Clipboard Add Text button event listener set up');
    }
    
    // Set up Enter key support for clipboard text input
    const clipboardTextInput = document.getElementById('clipboardTextInput');
    if (clipboardTextInput) {
      clipboardTextInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) {
          e.preventDefault();
          e.stopPropagation();
          setTimeout(() => addTextToClipboard(), 0);
        }
      }, { capture: true, passive: false });
      console.log('✅ Clipboard text input Enter key support set up');
    }
    
    // Skip file upload event listeners if we're on clipboard-only page
    const isClipboardOnly = typeof show_clipboard_only !== 'undefined' && show_clipboard_only;
    
    if (isClipboardOnly) {
      console.log('📋 Clipboard-only mode: Skipping file upload event listeners');
      
      // Only set up toast click handler for clipboard mode
      if (DOM_CACHE.toast) {
        DOM_CACHE.toast.addEventListener('click', function() {
          console.log('🔔 Toast clicked');
          const toast = this;
          
          // Clear any auto-hide timeout using the new system
          if (toastTimeout) {
            clearTimeout(toastTimeout);
            toastTimeout = null;
          }
          
          hideToast();
        });
      } else {
        console.warn('⚠️ Toast element not found in setupEventListeners');
      }
      
      console.log('✅ Clipboard event listeners set up successfully');
      return;
    }
    
    // Check if DOM elements are available before adding listeners (file sharing mode)
    if (!DOM_CACHE.dropZone || !DOM_CACHE.fileInput) {
      console.error('❌ Critical DOM elements not found:', {
        dropZone: !!DOM_CACHE.dropZone,
        fileInput: !!DOM_CACHE.fileInput
      });
      return;
    }

    ['dragenter', 'dragover'].forEach(evt =>
      DOM_CACHE.dropZone.addEventListener(evt, e => {
        e.preventDefault();
        DOM_CACHE.dropZone.classList.add('dragover');
      })
    );

    ['dragleave', 'drop'].forEach(evt =>
      DOM_CACHE.dropZone.addEventListener(evt, e => {
        e.preventDefault();
        DOM_CACHE.dropZone.classList.remove('dragover');
      })
    );

    DOM_CACHE.dropZone.addEventListener('drop', e => {
      console.log('📁 Drop event triggered');
      DOM_CACHE.fileInput.files = e.dataTransfer.files;
      console.log('📁 Files from drop:', e.dataTransfer.files.length);
      updatePreview(DOM_CACHE.fileInput.files);
      autoUpload(DOM_CACHE.fileInput.files);
    });

    DOM_CACHE.dropZone.addEventListener('click', () => {
      console.log('🖱️ Drop zone clicked, opening file input');
      DOM_CACHE.fileInput.click();
    });

    DOM_CACHE.fileInput.addEventListener('change', () => {
      console.log('📂 File input changed, files:', DOM_CACHE.fileInput.files.length);
      updatePreview(DOM_CACHE.fileInput.files);
      autoUpload(DOM_CACHE.fileInput.files);
    });

    // Set up toast click handler
    if (DOM_CACHE.toast) {
      DOM_CACHE.toast.addEventListener('click', function() {
        console.log('🔔 Toast clicked');
        const toast = this;
        
        // Clear any auto-hide timeout using the new system
        if (toastTimeout) {
          clearTimeout(toastTimeout);
          toastTimeout = null;
        }
        
        // If there's transfer data, show detailed log
        if (toast._transferData) {
          console.log('📊 Showing detailed transfer data');
          const data = toast._transferData;
          let detailedMessage;
          
          if (data.type === 'download' || data.type === 'direct_download_ultra_fast') {
            const timeRange = data.startTime && data.endTime ? 
              `${data.startTime} - ${data.endTime}` : 
              data.timestamp;
              
            // 🚀 PERFORMANCE: Use array join for efficient string building
            detailedMessage = [
              `📊 ${data.type.toUpperCase()}: ${data.filename}`,
              `📁 Size: ${data.size}`,
              `⚡ Server Response: ${data.serverResponseTime || 'N/A'}`,
              `⚙️ Processing Time: ${data.processingTime || data.downloadTime || 'N/A'}`,
              `⏱️ Total Time: ${data.totalTime || 'N/A'}`,
              `🌐 Protocol: ${location.protocol === 'https:' ? 'HTTPS' : 'HTTP'}`,
              `🕐 Time: ${timeRange}`,
              '',
              `💡 Click anywhere else to dismiss`
            ].join('\n');
          } else {
            const protocolInfo = data.protocol ? `🌐 Protocol: ${data.protocol}\n` : '';
            const chunkInfo = data.chunkType ? `📦 Transfer Type: ${data.chunkType}\n` : '';
            const networkInfo = data.networkSpeed ? `📡 Network Speed: ${data.networkSpeed}\n` : '';
            const finalChunkInfo = data.finalChunkSize ? `🔧 Final Chunk Size: ${data.finalChunkSize}\n` : '';
            const timeRange = data.startTime && data.endTime ? 
              `${data.startTime} - ${data.endTime}` : 
              data.timestamp;
              
            detailedMessage = `📊 ${data.type.toUpperCase()}: ${data.filename}\n` +
                             `📁 Size: ${data.size}\n` +
                             `⏱️ ${data.type === 'download' ? 'Download' : 'Upload'} Duration: ${data.time} @ ${data.speed}\n` +
                             chunkInfo +
                             networkInfo +
                             finalChunkInfo +
                             `🔒 AES: ${data.aesEnabled ? 'Yes' : 'No'}\n` +
                             protocolInfo +
                             `🕐 Time: ${timeRange}\n\n` +
                             `💡 Click anywhere else to dismiss`;
          }
          
          toast.style.whiteSpace = 'pre-line';
          toast.style.backgroundColor = '#2c3e50';
          toast.innerText = detailedMessage;
          lastToastMessage = detailedMessage; // Update the tracked message
          isPersistentToast = true; // Mark as persistent
          
          // Make it persistent (no auto-hide)
          toast.style.display = 'block';
          
        } else {
          console.log('📝 Making current toast persistent');
          // No transfer data, just make current message persistent
          toast.style.backgroundColor = '#2c3e50';
          isPersistentToast = true; // Mark as persistent
          toast.style.display = 'block';
          toast.title = 'Persistent message - click anywhere else to dismiss';
        }
      });
    } else {
      console.warn('⚠️ Toast element not found in setupEventListeners');
    }
    
    // 🖱️ Add global click handler to dismiss persistent toasts
    document.addEventListener('click', function globalToastClickHandler(e) {
      let toast = DOM_CACHE.toast;
      
      // Robust fallback for toast element
      if (!toast) {
        toast = document.getElementById('toast');
        if (toast) {
          DOM_CACHE.toast = toast;
        } else {
          return; // No toast element found
        }
      }
      
      if (e.target !== toast && !toast.contains(e.target)) {
        if (toast.style.backgroundColor === 'rgb(44, 62, 80)') { // Persistent mode (either completion or detailed view)
          hideToast(); // Use the new hide function
          
          // ✅ Reload page if this was an upload completion toast
          if (window._shouldReloadAfterToast) {
            window._shouldReloadAfterToast = false;
            location.reload();
          }
        }
      }
    });
  }

  function updatePreview(files) {
    DOM_CACHE.preview.innerHTML = '';
    if (!files.length) return;
    for (let file of files) {
      const div = document.createElement('div');
      div.textContent = `📄 ${file.name}`;
      DOM_CACHE.preview.appendChild(div);
    }
  }

  function clearFileSelection() {
    // Clear the file input (safe - doesn't affect active uploads)
    if (DOM_CACHE.fileInput) {
      DOM_CACHE.fileInput.value = '';
    }
    
    // Clear the preview area (safe - only affects UI)
    if (DOM_CACHE.preview) {
      DOM_CACHE.preview.innerHTML = '';
    }
    
    // Note: We do NOT clear uploadQueue or any active upload state here
    // This function only clears the file selection UI, not the upload manager
    
    console.log('🧹 File selection UI cleared (upload queue preserved)');
  }

  function displaySelectedFiles(files) {
    // For multiple files, show preview and let user manually upload if needed
    updatePreview(files);
    
    // Show helpful message for multiple files
    const totalSize = Array.from(files).reduce((sum, file) => sum + file.size, 0);
    const totalSizeMB = (totalSize / 1024 / 1024).toFixed(1);
    showToast(`📁 ${files.length} files selected (${totalSizeMB} MB total) - Auto-upload triggered`, 3000);
    
    // Actually trigger auto-upload for multiple files too
    autoUpload(files);
  }

function autoUpload(files) {
  console.log('🚀 autoUpload called with files:', files ? files.length : 'no files', files);
  
  if (!files.length) {
    console.log('❌ No files to upload');
    return;
  }

  // 🔄 Deduplication: Check for rapid duplicate selections
  if (!shouldProcessFileSelection(files)) {
    return;
  }

  // 🧹 Perform periodic memory cleanup
  performMemoryCleanup();

  const isAESEnabled = DOM_CACHE.aesToggle && DOM_CACHE.aesToggle.checked;
  const isHTTPS = location.protocol === 'https:';

  console.log('⚙️ Upload settings:', { isAESEnabled, isHTTPS });

  // ✅ NO SIZE LIMITS - Streaming encryption handles files of any size
  // Size limit check removed - AES now supports multi-gigabyte files
  console.log('🔒 AES enabled - streaming encryption supports any file size');

  // �️ HTTP-Safe AES: Allow AES over HTTP with metadata protection
  if (isAESEnabled && !isHTTPS) {
    console.log('🛡️ AES over HTTP - HTTP-Safe mode provides security');
    // No longer block AES over HTTP - HTTP-Safe mode handles security
  }

  // 📝 Log current upload queue state before adding new files
  const currentActiveUploads = uploadQueue.filter(item => 
    ['uploading'].includes(item.status)
  ).length;
  
  console.log(`📤 Current upload state: ${currentActiveUploads} active uploads, adding ${files.length} new files`);

  // 🚀 NEW: Add files to upload manager without interfering with active uploads
  addToUploadQueue(Array.from(files));
  
  // 🧹 Clear the file input and preview after adding to queue (safe operation)
  clearFileSelection();
  
  // Start uploading new files if possible (won't affect active uploads)
  startNextUpload();

  // 📊 Show feedback to user about adding files to active queue
  if (currentActiveUploads > 0) {
    showToast(`📤 Added ${files.length} file(s) to upload queue. ${currentActiveUploads} uploads currently active.`, 3000);
  } else {
    const optimalConcurrency = getOptimalConcurrency();
    const filesToStart = Math.min(optimalConcurrency, files.length);
    
    if (filesToStart > 1) {
      showToast(`🚀 Starting smart concurrent upload of ${files.length} file(s) (${filesToStart} concurrent)...`, 3000);
    } else {
      showToast(`🚀 Starting upload of ${files.length} file(s)...`, 3000);
    }
  }
}

// �️ HTTP-Safe AES Functions
function isHttpSafeEnabled() {
  const aesToggle = document.getElementById('enableEncryption');
  const isHTTP = location.protocol === 'http:';
  
  // Always enable HTTP-Safe mode when AES is used over HTTP
  if (isHTTP && aesToggle && aesToggle.checked) {
    return true;
  }
  
  // For HTTPS, HTTP-Safe mode is optional but still beneficial
  return aesToggle && aesToggle.checked;
}

async function encryptFileHttpSafe(file) {
  const formData = new FormData();
  formData.append('file', file);
  formData.append('http_safe', 'true');
  
  const response = await fetch('/encrypt_http_safe', {
    method: 'POST',
    body: formData
  });
  
  if (!response.ok) {
    throw new Error(`HTTP-Safe encryption failed: ${response.statusText}`);
  }
  
  const result = await response.json();
  return {
    encryptedBlob: await (await fetch(`/download_temp/${result.temp_filename}`)).blob(),
    metadata: result.metadata,
    obfuscatedFilename: result.obfuscated_filename,
    originalSize: file.size,
    encryptedSize: result.encrypted_size
  };
}

function createObfuscatedUpload(encryptedData, originalFile) {
  const obfuscatedFile = new File([encryptedData.encryptedBlob], encryptedData.obfuscatedFilename, {
    type: 'application/octet-stream'
  });
  
  // Add metadata as hidden field
  return {
    file: obfuscatedFile,
    metadata: encryptedData.metadata,
    originalName: originalFile.name,
    originalSize: encryptedData.originalSize,
    encryptedSize: encryptedData.encryptedSize
  };
}

async function generateDecoyTraffic() {
  if (!isHttpSafeEnabled()) return;
  
  const decoyCount = Math.floor(Math.random() * 3) + 1; // 1-3 decoys
  for (let i = 0; i < decoyCount; i++) {
    try {
      await fetch('/generate_decoy', { 
        method: 'POST',
        body: JSON.stringify({ size: Math.floor(Math.random() * 50000) + 10000 }),
        headers: { 'Content-Type': 'application/json' }
      });
    } catch (e) {
      // Ignore decoy failures
    }
  }
}

// 🛡️ HTTP-Safe AES Upload Function
async function uploadFilesHttpSafe(files) {
  try {
    updateToastContent('🛡️ HTTP-Safe AES: Preparing secure upload with metadata protection...');
    
    // Generate decoy traffic before upload
    await generateDecoyTraffic();
    
    const encryptedFiles = [];
    const totalOriginalSize = files.reduce((sum, file) => sum + file.size, 0);
    const totalOriginalSizeMB = (totalOriginalSize / 1024 / 1024).toFixed(2);
    
    updateToastContent(`🛡️ HTTP-Safe AES: Encrypting ${files.length} file(s) (${totalOriginalSizeMB} MB)...`);
    
    // Encrypt files with HTTP-Safe protection
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      updateToastContent(`🛡️ HTTP-Safe AES: Encrypting file ${i + 1}/${files.length}: ${file.name}`);
      
      const encryptedData = await encryptFileHttpSafe(file);
      const obfuscatedUpload = createObfuscatedUpload(encryptedData, file);
      encryptedFiles.push(obfuscatedUpload);
    }
    
    // Calculate encrypted sizes
    const totalEncryptedSize = encryptedFiles.reduce((sum, ef) => sum + ef.encryptedSize, 0);
    const totalEncryptedSizeMB = (totalEncryptedSize / 1024 / 1024).toFixed(2);
    
    updateToastContent(`🛡️ HTTP-Safe AES: Uploading ${encryptedFiles.length} protected file(s) (${totalEncryptedSizeMB} MB)...`);
    
    // Upload encrypted files
    const formData = new FormData();
    const metadataArray = [];
    
    for (const encFile of encryptedFiles) {
      formData.append('files', encFile.file);
      metadataArray.push({
        original_name: encFile.originalName,
        metadata: encFile.metadata,
        original_size: encFile.originalSize,
        encrypted_size: encFile.encryptedSize
      });
    }
    
    formData.append('http_safe_metadata', JSON.stringify(metadataArray));
    formData.append('encrypt', 'true');
    formData.append('http_safe', 'true');
    
    // Upload with progress tracking
    const xhr = new XMLHttpRequest();
    progressBar.style.display = 'block';
    progressBar.value = 0;
    
    const startTime = new Date().getTime();
    
    xhr.upload.addEventListener('progress', (e) => {
      if (e.lengthComputable) {
        const percent = (e.loaded / e.total) * 100;
        progressBar.value = percent;
        
        const elapsed = (new Date().getTime() - startTime) / 1000;
        const uploadedMB = (e.loaded / 1024 / 1024).toFixed(1);
        const speed = elapsed > 0 ? (e.loaded / 1024 / 1024 / elapsed).toFixed(2) : '0.00';
        
        updateToastContent(`🛡️ HTTP-Safe AES: Uploading ${percent.toFixed(1)}% (${uploadedMB}/${totalEncryptedSizeMB} MB) @ ${speed} MB/s`);
      }
    });
    
    return new Promise((resolve, reject) => {
      xhr.onload = () => {
        window._qrBlocked = false;
        progressBar.style.display = 'none';
        
        if (xhr.status === 200) {
          const elapsed = (new Date().getTime() - startTime) / 1000;
          const avgSpeed = (totalEncryptedSize / 1024 / 1024 / elapsed).toFixed(2);
          
          showToast(`✅ HTTP-Safe AES Upload Complete! ${files.length} file(s) (${totalOriginalSizeMB} MB) uploaded securely with metadata protection in ${elapsed.toFixed(1)}s @ ${avgSpeed} MB/s`, 5000);
          
          try {
            const response = JSON.parse(xhr.responseText);
            displayUploadedFiles(response.files || []);
          } catch (e) {
            console.warn('Response parsing issue:', e);
          }
          
          resolve();
        } else {
          showToast(`❌ HTTP-Safe upload failed: ${xhr.statusText}`, 5000);
          reject(new Error(`Upload failed: ${xhr.statusText}`));
        }
      };
      
      xhr.onerror = () => {
        window._qrBlocked = false;
        progressBar.style.display = 'none';
        showToast('❌ HTTP-Safe upload failed due to network error', 5000);
        reject(new Error('Network error'));
      };
      
      xhr.open('POST', '/upload');
      xhr.send(formData);
    });
    
  } catch (error) {
    window._qrBlocked = false;
    progressBar.style.display = 'none';
    showToast(`❌ HTTP-Safe AES encryption failed: ${error.message}`, 5000);
    throw error;
  }
}

// �🔄 Regular upload function (original logic) - supports HTTP & HTTPS
function uploadFilesRegular(files, isAESEnabled) {
  // Block QR generation during uploads to prevent UI blocking
  window._qrBlocked = true;
  
  const formData = new FormData();
  
  // 🚀 PERFORMANCE: Calculate total size efficiently
  let totalSize = 0;
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    formData.append('files', file);
    totalSize += file.size;
  }
  
  const totalSizeMB = (totalSize / 1024 / 1024).toFixed(2);
  const isHTTPS = location.protocol === 'https:';
  const protocolMsg = isHTTPS ? "HTTPS" : "HTTP";

  // ✅ Pass AES status to backend (using correct parameter name)
  if (isAESEnabled) {
    formData.append('encrypt', 'true');
    // Show enhanced AES operation progress
    updateToastContent(`🔒 AES-256 encryption enabled - Processing ${totalSizeMB} MB file(s) for secure upload...`);
    console.log('🔐 Starting AES encryption for regular upload');
  }

  const xhr = new XMLHttpRequest();
  progressBar.style.display = 'block';
  progressBar.value = 0;
  
  // Smoothly update the existing toast instead of creating a new one
  updateToastContent(`⏳ Starting ${protocolMsg} upload...`);

  const startTime = new Date().getTime();
  let lastProgressUpdate = 0;
  const PROGRESS_UPDATE_INTERVAL = LANVAN_CONFIG.INTERVALS.PROGRESS_UPDATE; // Unified interval from config

  xhr.upload.onprogress = function (e) {
    if (e.lengthComputable) {
      const percent = (e.loaded / e.total) * 100;
      progressBar.value = percent;
      
      // 📱 Anti-blink: Update toast much less frequently
      const now = Date.now();
      if (now - lastProgressUpdate >= PROGRESS_UPDATE_INTERVAL || percent >= 100) {
        const elapsed = (now - startTime) / 1000;
        const speed = e.loaded / 1024 / 1024 / elapsed;
        const uploadedMB = (e.loaded / 1024 / 1024).toFixed(1);
        
        // 📊 Enhanced progress message for multiple files with AES status
        let progressMessage;
        if (files.length === 1) {
          const aesStatus = isAESEnabled ? " 🔐" : "";
          progressMessage = `📤 Uploading${aesStatus} ${percent.toFixed(1)}% (${uploadedMB}/${totalSizeMB} MB) @ ${speed.toFixed(2)} MB/s`;
        } else {
          const aesStatus = isAESEnabled ? " (AES Encrypted)" : "";
          progressMessage = `📤 Uploading ${files.length} files${aesStatus} • ${percent.toFixed(1)}% (${uploadedMB}/${totalSizeMB} MB) @ ${speed.toFixed(2)} MB/s`;
        }
        updateProgressToast(progressMessage);
      }
    }
  };

  xhr.onload = function () {
    const endTime = new Date().getTime();
    const totalElapsed = ((endTime - startTime) / 1000).toFixed(1);
    const avgSpeed = (totalSize / 1024 / 1024 / totalElapsed).toFixed(2);
    
    if (xhr.status === 200 || xhr.status === 302) {
      // Update performance metrics in LANVAN_STATE
      LANVAN_STATE.performance.totalUploaded += totalSize;
      const currentSession = (endTime - LANVAN_STATE.performance.sessionsStartTime) / 1000;
      LANVAN_STATE.performance.averageSpeed = LANVAN_STATE.performance.totalUploaded / (1024 * 1024) / currentSession;

      // Save upload stats to logs
      const uploadStats = {
        type: 'Direct Upload',
        filename: files.length > 1 ? `${files.length} files` : files[0].name,
        size: totalSizeMB + ' MB',
        time: totalElapsed + 's',
        speed: avgSpeed + ' MB/s',
        method: 'Direct Upload (No Chunks)',
        chunks_used: 0, // No chunks for direct upload
        encrypted: isAESEnabled,
        protocol: protocolMsg,
        files_count: files.length,
        timestamp: new Date().toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true }),
        startTime: new Date(startTime).toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true }),
        endTime: new Date(endTime).toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true })
      };
      saveStatsToLog(uploadStats);
      
      // 💾 Store file metadata for better download experience
      storeFileMetadata(files, totalSize);
      
      // 📊 Enhanced completion message for multiple files
      if (files.length === 1) {
        showToast(`✅ Upload complete via ${protocolMsg} (${totalSizeMB} MB) • ${totalElapsed}s @ ${avgSpeed} MB/s`, 0, uploadStats);
      } else {
        showToast(`✅ ${files.length} files uploaded via ${protocolMsg} (${totalSizeMB} MB total) • ${totalElapsed}s @ ${avgSpeed} MB/s`, 0, uploadStats);
      }
      
      // 🔄 Delay file list refresh to show completion status
      setTimeout(() => {
        refreshFileList();
      }, 3000); // 3 second delay to let user see completion
      
      // Store flag to reload page when toast is dismissed (optional)
      window._shouldReloadAfterToast = false; // Changed to false since we auto-refresh
      
      // Unblock QR generation after successful upload
      window._qrBlocked = false;
      
      // End upload tracking
      endUpload();
    } else {
      showToast('❌ Upload failed • Click anywhere to dismiss', 0);
      // Unblock QR generation after failed upload
      window._qrBlocked = false;
      endUpload(); // End upload tracking on failure
    }
  };

  xhr.onerror = function () {
    showToast('❌ Upload error • Click anywhere to dismiss', 0);
    endUpload(); // End upload tracking on error
  };

  xhr.open('POST', '/upload-auto');
  xhr.send(formData);
}

// 🔍 Device capability detection functions for guest device support
function detectGuestDevice() {
  try {
    // Check for limited device indicators
    const isLimitedMemory = navigator.deviceMemory && navigator.deviceMemory <= 2; // 2GB or less
    const isLimitedConcurrency = navigator.hardwareConcurrency && navigator.hardwareConcurrency <= 2; // 2 cores or less
    const isIncognito = checkIncognitoMode();
    
    // Additional checks for guest/shared devices
    const hasLimitedStorage = checkStorageQuota();
    const isSlowDevice = checkDevicePerformance();
    
    return isLimitedMemory || isLimitedConcurrency || isIncognito || hasLimitedStorage || isSlowDevice;
  } catch (e) {
    console.log('Device detection failed, assuming guest device for safety:', e);
    return true; // Default to guest device for safety
  }
}

function checkStorageQuota() {
  try {
    if ('storage' in navigator && 'estimate' in navigator.storage) {
      navigator.storage.estimate().then(estimate => {
        const quota = estimate.quota || 0;
        const usage = estimate.usage || 0;
        return quota < 1024 * 1024 * 1024; // Less than 1GB available
      });
    }
    return false;
  } catch (e) {
    return true; // Assume limited if check fails
  }
}

function checkDevicePerformance() {
  try {
    const start = performance.now();
    // Simple CPU test
    for (let i = 0; i < 100000; i++) {
      Math.random();
    }
    const duration = performance.now() - start;
    return duration > 50; // Slow if takes more than 50ms
  } catch (e) {
    return true; // Assume slow if test fails
  }
}

// 📦 Optimized network-adaptive chunked upload function for large files (≥250MB) - supports HTTP & HTTPS
async function uploadFilesChunked(files, isAESEnabled) {
  // Block QR generation during uploads to prevent UI blocking
  window._qrBlocked = true;
  
  // 🔍 Device capability detection for guest device support
  const isGuestDevice = detectGuestDevice();
  const deviceMemoryMB = getDeviceMemory();
  
  // 🔄 Comprehensive retry tracking system
  let totalRetries = 0;
  let totalChunkFailures = 0;
  let totalFinalizeRetries = 0;
  const retryHistory = []; // Track retry events for debugging
  
  // 🚀 Memory-Aware Network-Adaptive Chunk Sizing System (Using Centralized Config)
  let CHUNK_SIZE = isGuestDevice ? LANVAN_CONFIG.CHUNK_SIZES.GUEST_INITIAL : LANVAN_CONFIG.CHUNK_SIZES.REGULAR_INITIAL;
  const MIN_CHUNK_SIZE = isGuestDevice ? LANVAN_CONFIG.CHUNK_SIZES.GUEST_MIN : LANVAN_CONFIG.CHUNK_SIZES.REGULAR_MIN;
  const MAX_CHUNK_SIZE = isGuestDevice ? LANVAN_CONFIG.CHUNK_SIZES.GUEST_MAX : LANVAN_CONFIG.CHUNK_SIZES.REGULAR_MAX;
  let networkSpeed = 0; // MB/s
  let speedSamples = []; // Simplified tracking
  
  // 🚀 PERFORMANCE: Calculate total size and check for .enc files efficiently
  let totalSize = 0;
  let hasEncFiles = false;
  
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    totalSize += file.size;
    if (!hasEncFiles && file.name.endsWith('.enc')) {
      hasEncFiles = true;
    }
  }
  
  const totalSizeMB = (totalSize / 1024 / 1024).toFixed(2);
  const isHTTPS = location.protocol === 'https:';
  
  // ⚠️ Guest device large file warning
  if (isGuestDevice && totalSize > LANVAN_CONFIG.GUEST_MEMORY_LIMIT) {
    const fileSizeGB = (totalSize / 1024 / 1024 / 1024).toFixed(1);
    console.warn(`⚠️ Large file upload (${fileSizeGB}GB) detected on guest device. This may cause memory issues.`);
    showToast(`⚠️ Large file (${fileSizeGB}GB) on guest device may cause issues. Consider using regular upload or a smaller file.`, 5000);
  }
  
  // 🚫 Block .enc files from chunked upload on HTTPS
  if (hasEncFiles && isHTTPS) {
    showToast("❌ .enc files cannot use chunked upload on HTTPS. Please use full upload to preserve encryption integrity.", 5000);
    return;
  }
  
  progressBar.style.display = 'block';
  progressBar.value = 0;
  
  const startTime = new Date().getTime();
  let totalUploaded = 0;
  let lastToastUpdate = 0;
  const TOAST_UPDATE_INTERVAL = LANVAN_CONFIG.INTERVALS.TOAST_UPDATE; // Unified interval from config
  
  const protocolMsg = isHTTPS ? "HTTPS" : "HTTP";
  
  if (isGuestDevice) {
    updateToastContent(`⏳ Starting adaptive-chunked upload over ${protocolMsg} (guest device with full performance)...`);
    console.log(`🔍 Guest device detected - using unified high-performance chunk sizes: ${(MIN_CHUNK_SIZE/1024/1024).toFixed(1)}MB to ${(MAX_CHUNK_SIZE/1024/1024).toFixed(1)}MB`);
  } else {
    updateToastContent(`⏳ Starting adaptive-chunked upload over ${protocolMsg}...`);
  }

  // 🎯 Simplified memory-aware chunk size adaptation using configuration
  function adaptChunkSize(speed) {
    const thresholds = LANVAN_CONFIG.SPEED_THRESHOLDS;
    
    if (isGuestDevice) {
      // Conservative chunking for guest devices to prevent memory issues
      if (speed > thresholds.VERY_FAST) { // > 25 MB/s
        CHUNK_SIZE = Math.min(MAX_CHUNK_SIZE, 16 * 1024 * 1024); // 16MB max
      } else if (speed > thresholds.MEDIUM_FAST) { // > 8 MB/s
        CHUNK_SIZE = Math.min(MAX_CHUNK_SIZE, 8 * 1024 * 1024); // 8MB max
      } else if (speed > thresholds.MEDIUM) { // > 4 MB/s
        CHUNK_SIZE = Math.min(MAX_CHUNK_SIZE, 4 * 1024 * 1024); // 4MB max
      } else { // <= 4 MB/s - minimum chunks
        CHUNK_SIZE = Math.max(MIN_CHUNK_SIZE, 2 * 1024 * 1024); // 2MB minimum
      }
    } else {
      // Simplified adaptation for powerful devices
      if (speed > thresholds.ULTRA_FAST) { // > 40 MB/s
        CHUNK_SIZE = MAX_CHUNK_SIZE;
      } else if (speed > thresholds.VERY_FAST) { // > 25 MB/s
        CHUNK_SIZE = Math.min(MAX_CHUNK_SIZE, 80 * 1024 * 1024); // 80MB
      } else if (speed > thresholds.FAST) { // > 15 MB/s
        CHUNK_SIZE = Math.min(MAX_CHUNK_SIZE, 48 * 1024 * 1024); // 48MB
      } else if (speed > thresholds.MEDIUM_FAST) { // > 8 MB/s
        CHUNK_SIZE = Math.min(MAX_CHUNK_SIZE, 24 * 1024 * 1024); // 24MB
      } else if (speed > thresholds.MEDIUM) { // > 4 MB/s
        CHUNK_SIZE = Math.min(MAX_CHUNK_SIZE, Math.max(CHUNK_SIZE, 12 * 1024 * 1024)); // 12MB minimum
      } else if (speed < thresholds.SLOW) { // < 2 MB/s
        CHUNK_SIZE = Math.max(MIN_CHUNK_SIZE, CHUNK_SIZE * 0.8);
      }
      // For 2-4 MB/s range, keep current chunk size stable
    }
    return Math.round(CHUNK_SIZE);
  }

  try {
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const fileSize = file.size;
      const currentFileNum = i + 1;
      const fileSizeMB = (fileSize / 1024 / 1024).toFixed(1);
      
      // 📊 Dynamic chunk estimation (will adapt during upload)
      let estimatedChunks = Math.ceil(fileSize / CHUNK_SIZE);
      if (files.length === 1) {
        updateToastContent(`📦 Processing ${file.name} (${fileSizeMB} MB) - ~${estimatedChunks} adaptive chunks (starting at ${(CHUNK_SIZE/1024/1024).toFixed(0)}MB)`);
      } else {
        updateToastContent(`📦 File ${currentFileNum}/${files.length}: ${file.name} (${fileSizeMB} MB) - ~${estimatedChunks} adaptive chunks`);
      }

      // 🚀 Dynamic chunk processing with byte-position tracking (not chunk index)
      let currentPosition = 0;
      let partNumber = 1;
      let chunkCount = 0;

      while (currentPosition < fileSize) {
        // 🔍 Optimized memory monitoring for guest device protection (reduced frequency)
        if (isGuestDevice && chunkCount % LANVAN_CONFIG.MEMORY.GC_FREQUENCY === 0) {
          try {
            // Check available memory before creating large chunks (only every N chunks)
            if (performance.memory && performance.memory.usedJSHeapSize) {
              const usedMemoryMB = performance.memory.usedJSHeapSize / (1024 * 1024);
              const limitMemoryMB = performance.memory.jsHeapSizeLimit / (1024 * 1024);
              const memoryUsagePercent = (usedMemoryMB / limitMemoryMB) * 100;
              
              // If memory usage is high, reduce chunk size
              if (memoryUsagePercent > LANVAN_CONFIG.MEMORY.HIGH_USAGE_THRESHOLD) {
                CHUNK_SIZE = Math.max(MIN_CHUNK_SIZE, CHUNK_SIZE * 0.5);
                console.log(`🔥 High memory usage (${memoryUsagePercent.toFixed(1)}%), reducing chunk size to ${(CHUNK_SIZE/1024/1024).toFixed(1)}MB`);
              }
            }
          } catch (memError) {
            console.log('Memory monitoring failed, continuing with current chunk size:', memError);
          }
        }
        
        const chunkStartTime = Date.now();
        const end = Math.min(currentPosition + CHUNK_SIZE, fileSize);
        
        // 💾 Safe chunk creation with memory protection and explicit cleanup
        let chunk;
        try {
          chunk = file.slice(currentPosition, end);
          
          // Verify chunk was created successfully
          if (!chunk || chunk.size === 0) {
            throw new Error(`Failed to create chunk at position ${currentPosition}`);
          }
          
          // Additional safety check for guest devices
          if (isGuestDevice && chunk.size > LANVAN_CONFIG.CHUNK_SIZES.GUEST_MAX) {
            console.warn(`⚠️ Large chunk detected on guest device (${(chunk.size/1024/1024).toFixed(1)}MB), this may cause issues`);
          }
        } catch (chunkError) {
          throw new Error(`Memory error creating chunk: ${chunkError.message}. Try refreshing the page or using a smaller file.`);
        }

        // Create FormData for chunk with explicit cleanup tracking
        let chunkFormData = new FormData();
        chunkFormData.append('chunk', chunk);
        chunkFormData.append('filename', file.name);
        chunkFormData.append('part_number', partNumber.toString());
        chunkFormData.append('total_parts', estimatedChunks.toString()); // Send current estimate

        // 📊 Save chunk size BEFORE upload attempts for performance tracking
        const chunkSize = chunk.size;

        // Upload chunk with retry mechanism
        let retryCount = 0;
        let chunkResponse;
        let chunkResult;
        
        while (retryCount <= LANVAN_CONFIG.ERROR_RECOVERY.MAX_RETRIES) {
          try {
            // 🚀 PERFORMANCE: AbortController for proper request cleanup
            const abortController = new AbortController();
            const timeoutId = setTimeout(() => abortController.abort(), LANVAN_CONFIG.ERROR_RECOVERY.NETWORK_TIMEOUT);
            
            chunkResponse = await fetch('/upload_chunk', {
              method: 'POST',
              body: chunkFormData,
              signal: abortController.signal
            });
            
            clearTimeout(timeoutId);

            if (!chunkResponse.ok) {
              throw new Error(`HTTP ${chunkResponse.status}`);
            }
            
            // Verify chunk upload success
            chunkResult = await chunkResponse.json();
            if (chunkResult.status !== 'success') {
              throw new Error(chunkResult.msg || `Chunk ${partNumber} upload was not successful`);
            }
            
            // Success - break out of retry loop
            break;
            
          } catch (error) {
            retryCount++;
            totalRetries++;
            
            // Log retry event for debugging
            const retryEvent = {
              chunkNumber: partNumber,
              fileName: file.name,
              attempt: retryCount,
              error: error.message,
              timestamp: new Date().toISOString(),
              chunkSize: (chunkSize / 1024 / 1024).toFixed(1) + 'MB'
            };
            retryHistory.push(retryEvent);
            
            console.log(`🔄 Chunk ${partNumber} attempt ${retryCount} failed:`, error.message);
            
            if (retryCount > LANVAN_CONFIG.ERROR_RECOVERY.MAX_RETRIES) {
              totalChunkFailures++;
              
              // Critical: Clean up chunk memory before throwing error
              chunk = null;
              chunkFormData = null;
              throw new Error(`Chunk ${partNumber} failed after ${LANVAN_CONFIG.ERROR_RECOVERY.MAX_RETRIES} retries: ${error.message}`);
            }
            
            // Wait before retry with exponential backoff
            const delayMs = LANVAN_CONFIG.ERROR_RECOVERY.RETRY_DELAY * Math.pow(LANVAN_CONFIG.ERROR_RECOVERY.EXPONENTIAL_BACKOFF, retryCount - 1);
            console.log(`⏳ Retrying chunk ${partNumber} in ${delayMs}ms... (Total retries so far: ${totalRetries})`);
            
            // Show retry message for user feedback
            if (retryCount === 1) {
              updateToastContent(`🔄 Network issue, retrying chunk ${partNumber}... (${totalRetries} total retries)`);
            }
            
            await new Promise(resolve => setTimeout(resolve, delayMs));
          }
        }
        
        // Calculate timing after successful upload
        const chunkDuration = (Date.now() - chunkStartTime) / 1000;
        
        // 🧹 CRITICAL MEMORY CLEANUP: Explicitly dispose of chunk data after successful upload
        chunk = null;
        chunkFormData = null;
        
        // Force garbage collection hints for guest devices
        if (isGuestDevice && chunkCount % LANVAN_CONFIG.MEMORY.GC_FREQUENCY === 0) {
          // Trigger GC if available (Chrome DevTools or --js-flags=--expose-gc)
          if (typeof window.gc === 'function') {
            window.gc();
            console.log(`🧹 Forced garbage collection after chunk ${chunkCount}`);
          }
          // Additional memory pressure relief
          if (typeof window.performance?.memory !== 'undefined') {
            const usedMB = window.performance.memory.usedJSHeapSize / (1024 * 1024);
            console.log(`💾 Memory usage: ${usedMB.toFixed(1)}MB after chunk ${chunkCount}`);
          }
        }
        
        // Optional: Log chunk success for debugging (using saved chunk size)
        if (chunkCount <= 5 || chunkCount % 20 === 0) {
          console.log(`✅ Chunk ${partNumber} uploaded successfully (${(chunkSize/1024/1024).toFixed(1)}MB)`);
        }

        chunkCount++;

        // 🚀 Optimized performance tracking - using saved chunk data
        const currentChunkSpeed = (chunkSize / 1024 / 1024) / chunkDuration;
        
        if (chunkCount === 2) {
          // Quick initial assessment after 2nd chunk
          speedSamples.push(currentChunkSpeed);
          networkSpeed = currentChunkSpeed;
          
          // Early adaptation if speed is good
          if (currentChunkSpeed > LANVAN_CONFIG.SPEED_THRESHOLDS.FAST) {
            CHUNK_SIZE = adaptChunkSize(currentChunkSpeed);
          }
        } else if (chunkCount > 2 && chunkCount % LANVAN_CONFIG.INTERVALS.CHUNK_ADAPTATION === 0) {
          // Regular adaptation using configuration interval for responsive optimization
          
          speedSamples.push(currentChunkSpeed);
          if (speedSamples.length > 5) speedSamples.shift(); // Keep 5 samples for better accuracy
          
          if (speedSamples.length >= 3) {
            const avgSpeed = speedSamples.reduce((a, b) => a + b, 0) / speedSamples.length;
            const oldChunkSize = CHUNK_SIZE;
            CHUNK_SIZE = adaptChunkSize(avgSpeed);
            networkSpeed = avgSpeed;
            
            // Update estimated chunks when chunk size changes significantly
            if (Math.abs(CHUNK_SIZE - oldChunkSize) > (4 * 1024 * 1024)) { // 4MB difference
              const remainingBytes = fileSize - currentPosition - chunkSize;
              const remainingChunks = Math.ceil(remainingBytes / CHUNK_SIZE);
              estimatedChunks = chunkCount + remainingChunks;
            }
          }
        }

        // Update progress bar immediately (smooth) - using saved chunk size
        totalUploaded += chunkSize;
        const overallProgress = (totalUploaded / totalSize) * 100;
        progressBar.value = overallProgress;

        // 📊 Reduced toast updates to minimize UI overhead
        const now = Date.now();
        const isLastChunk = (currentPosition + chunkSize >= fileSize);
        const isSignificantProgress = (chunkCount % 10 === 0); // Every 10th chunk
        
        if (now - lastToastUpdate >= TOAST_UPDATE_INTERVAL || isLastChunk || isSignificantProgress) {
          const elapsed = (now - startTime) / 1000;
          const speed = totalUploaded / 1024 / 1024 / elapsed;
          const uploadedMB = (totalUploaded / 1024 / 1024).toFixed(1);
          const currentChunkSizeMB = (CHUNK_SIZE / 1024 / 1024).toFixed(1);
          
          // 📊 Enhanced progress message with dynamic chunk info and AES status
          if (files.length === 1) {
            const aesStatus = isAESEnabled ? " 🔐" : "";
            updateProgressToast(`📤${aesStatus} ${overallProgress.toFixed(0)}% • ${uploadedMB}/${totalSizeMB} MB @ ${speed.toFixed(1)} MB/s • ${currentChunkSizeMB}MB chunks (${chunkCount}/${estimatedChunks})`);
          } else {
            const aesStatus = isAESEnabled ? " (AES)" : "";
            updateProgressToast(`📤 File ${currentFileNum}/${files.length}${aesStatus} • ${overallProgress.toFixed(0)}% • ${uploadedMB}/${totalSizeMB} MB @ ${speed.toFixed(1)} MB/s • ${currentChunkSizeMB}MB chunks`);
          }
          lastToastUpdate = now;
        }

        // Move to next chunk position (using saved chunk size)
        currentPosition += chunkSize;
        partNumber++;
      }

      // Finalize the file (combine chunks) with retry mechanism
      if (files.length === 1) {
        updateToastContent(`🔗 Finalizing ${file.name} (${chunkCount} chunks)...`);
      } else {
        updateToastContent(`🔗 Finalizing file ${currentFileNum}/${files.length}: ${file.name} (${chunkCount} chunks)...`);
      }
      
      const finalizeFormData = new FormData();
      finalizeFormData.append('filename', file.name);
      finalizeFormData.append('total_parts', chunkCount.toString()); // Use actual chunk count
      if (isAESEnabled) {
        finalizeFormData.append('encrypt', 'true');
      }

      let finalizeRetryCount = 0;
      let finalizeResponse;
      let finalizeData;
      
      while (finalizeRetryCount <= LANVAN_CONFIG.ERROR_RECOVERY.MAX_RETRIES) {
        try {
          // 🚀 PERFORMANCE: AbortController for proper request cleanup
          const finalizeAbortController = new AbortController();
          const finalizeTimeoutId = setTimeout(() => finalizeAbortController.abort(), LANVAN_CONFIG.ERROR_RECOVERY.NETWORK_TIMEOUT);
          
          finalizeResponse = await fetch('/finalize_upload', {
            method: 'POST',
            body: finalizeFormData,
            signal: finalizeAbortController.signal
          });
          
          clearTimeout(finalizeTimeoutId);

          if (!finalizeResponse.ok) {
            throw new Error(`Finalize HTTP ${finalizeResponse.status}`);
          }
          
          // Get finalize response data for better feedback
          finalizeData = await finalizeResponse.json();
          if (finalizeData.actual_chunks !== chunkCount) {
            console.log(`Note: Server found ${finalizeData.actual_chunks} chunks, expected ${chunkCount}`);
          }
          
          // Success - break out of retry loop
          break;
          
        } catch (error) {
          finalizeRetryCount++;
          totalFinalizeRetries++;
          totalRetries++;
          
          // Log finalize retry event
          const finalizeRetryEvent = {
            fileName: file.name,
            finalizeAttempt: finalizeRetryCount,
            error: error.message,
            timestamp: new Date().toISOString(),
            chunkCount: chunkCount
          };
          retryHistory.push(finalizeRetryEvent);
          
          console.log(`🔄 Finalize attempt ${finalizeRetryCount} failed:`, error.message);
          
          if (finalizeRetryCount > LANVAN_CONFIG.ERROR_RECOVERY.MAX_RETRIES) {
            throw new Error(`Failed to finalize ${file.name} after ${LANVAN_CONFIG.ERROR_RECOVERY.MAX_RETRIES} retries: ${error.message}`);
          }
          
          // Wait before retry with exponential backoff
          const delayMs = LANVAN_CONFIG.ERROR_RECOVERY.RETRY_DELAY * Math.pow(LANVAN_CONFIG.ERROR_RECOVERY.EXPONENTIAL_BACKOFF, finalizeRetryCount - 1);
          console.log(`⏳ Retrying finalize in ${delayMs}ms... (Total retries: ${totalRetries})`);
          
          // Show retry message for user feedback
          if (finalizeRetryCount === 1) {
            updateToastContent(`🔄 Finalizing retry for ${file.name}... (${totalRetries} total retries)`);
          }
          
          await new Promise(resolve => setTimeout(resolve, delayMs));
        }
      }
    }

    // Success - all files uploaded
    const endTime = new Date().getTime();
    const totalElapsed = ((endTime - startTime) / 1000).toFixed(1);
    const avgSpeed = (totalSize / 1024 / 1024 / totalElapsed).toFixed(2);
    const finalChunkSizeMB = (CHUNK_SIZE / 1024 / 1024).toFixed(1);

    // Update performance metrics in LANVAN_STATE
    LANVAN_STATE.performance.totalUploaded += totalSize;
    const currentSession = (endTime - LANVAN_STATE.performance.sessionsStartTime) / 1000;
    LANVAN_STATE.performance.averageSpeed = LANVAN_STATE.performance.totalUploaded / (1024 * 1024) / currentSession;

    const uploadStats = {
      type: 'Adaptive Chunked Upload',
      filename: files.length > 1 ? `${files.length} files` : files[0].name,
      size: totalSizeMB + ' MB',
      time: totalElapsed + 's',
      speed: avgSpeed + ' MB/s',
      method: 'Adaptive Chunking',
      chunks_used: partNumber - 1, // Total chunks used
      chunkType: `Adaptive (${(MIN_CHUNK_SIZE/1024/1024).toFixed(0)}MB-${MAX_CHUNK_SIZE/1024/1024}MB)`,
      finalChunkSize: finalChunkSizeMB + 'MB',
      networkSpeed: networkSpeed.toFixed(1) + ' MB/s',
      encrypted: isAESEnabled,
      protocol: protocolMsg,
      retryCount: totalRetries, // ✅ COMPLETED: Track total retries across all chunks
      chunkRetries: totalRetries - totalFinalizeRetries,
      finalizeRetries: totalFinalizeRetries,
      chunkFailures: totalChunkFailures,
      retryHistory: retryHistory.length > 0 ? retryHistory : null,
      guestDevice: isGuestDevice,
      deviceMemory: deviceMemoryMB + 'MB',
      timestamp: new Date().toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true }),
      startTime: new Date(startTime).toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true }),
      endTime: new Date(endTime).toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true })
    };
    saveStatsToLog(uploadStats);
    
    // 💾 Store file metadata for better download experience
    storeFileMetadata(files, totalSize);
    
    // 📊 Enhanced completion message for multiple files with adaptive info
    if (files.length === 1) {
      showToast(`✅ Adaptive-chunked upload complete via ${protocolMsg} (${totalSizeMB} MB) • ${totalElapsed}s @ ${avgSpeed} MB/s • Final chunk: ${finalChunkSizeMB}MB`, 0, uploadStats);
    } else {
      showToast(`✅ ${files.length} files adaptive-chunked upload complete via ${protocolMsg} (${totalSizeMB} MB total) • ${totalElapsed}s @ ${avgSpeed} MB/s • Final chunk: ${finalChunkSizeMB}MB`, 0, uploadStats);
    }
    
    // 🔄 Delay file list refresh to show chunked completion status
    setTimeout(() => {
      refreshFileList();
    }, 3000); // 3 second delay to let user see completion
    
    // Store flag to reload page when toast is dismissed (optional)
    window._shouldReloadAfterToast = false; // Changed to false since we auto-refresh
    
    // End upload tracking
    endUpload();

  } catch (error) {
    // 🔍 Enhanced error handling with guest device support
    let errorMessage = error.message;
    let suggestionMessage = '';
    
    // Track error in LANVAN_STATE for debugging
    LANVAN_STATE.errors.push({
      type: 'adaptive_chunked_upload',
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString(),
      context: {
        files: files.length,
        totalSize: totalSizeMB + ' MB',
        isGuestDevice: isGuestDevice,
        deviceMemory: deviceMemoryMB + ' MB',
        chunkSize: (CHUNK_SIZE / 1024 / 1024).toFixed(1) + ' MB'
      }
    });
    
    // Keep only last 10 errors to prevent memory bloat
    if (LANVAN_STATE.errors.length > 10) {
      LANVAN_STATE.errors.splice(0, LANVAN_STATE.errors.length - 10);
    }
    
    if (isGuestDevice) {
      if (totalSize > 1024 * 1024 * 1024) { // Files larger than 1GB
        suggestionMessage = ' • For large files on guest devices, try: 1) Use a smaller file, 2) Split the file, 3) Use the regular upload, or 4) Use a device with more memory.';
      } else {
        suggestionMessage = ' • Guest device detected. Try refreshing the page or using regular upload if issues persist.';
      }
    }
    
    // Check for specific error types
    if (error.message.includes('Memory') || error.message.includes('memory')) {
      errorMessage = 'Out of memory error';
      suggestionMessage = ' • Try using a smaller file, closing other browser tabs, or refreshing the page.';
    } else if (error.message.includes('chunk') && error.message.includes('Failed to create')) {
      errorMessage = 'File processing error';
      suggestionMessage = ' • The file may be too large for this device. Try using regular upload or a smaller file.';
    }
    
    showToast(`❌ Adaptive-chunked upload failed: ${errorMessage}${suggestionMessage} • Click anywhere to dismiss`, 0);
    
    // End upload tracking on error
    endUpload();
    console.error('Adaptive-chunked upload error details:', {
      error: error,
      message: error.message,
      stack: error.stack,
      files: files.length,
      totalSize: totalSizeMB + ' MB',
      isGuestDevice: isGuestDevice,
      deviceMemory: deviceMemoryMB + ' MB',
      chunkSize: (CHUNK_SIZE / 1024 / 1024).toFixed(1) + ' MB'
    });
  }
}

// 🔔 Toast Notification System - Complete implementation
let toastTimeout = null;
let lastToastMessage = '';
let isPersistentToast = false;

function showToast(message, duration = 3000, transferData = null, type = 'default') {
  const toast = DOM_CACHE.toast;
  if (!toast) {
    console.warn('⚠️ Toast element not found');
    return;
  }
  
  // Clear any existing timeout
  if (toastTimeout) {
    clearTimeout(toastTimeout);
    toastTimeout = null;
  }
  
  // Reset persistent state
  isPersistentToast = false;
  
  // Set message and data
  toast.innerText = message;
  lastToastMessage = message;
  
  // Store transfer data for detailed view
  if (transferData) {
    toast._transferData = transferData;
  } else {
    delete toast._transferData;
  }
  
  // Determine background color based on type and duration
  let backgroundColor = '#333'; // Default
  if (duration === 0) { // Persistent toast
    if (type === 'error') {
      backgroundColor = '#dc3545'; // Red for error
    } else if (type === 'warning') {
      backgroundColor = '#ffc107'; // Yellow for warning
    } else {
      backgroundColor = '#27ae60'; // Green for success/default persistent
    }
  } else {
    // Non-persistent toasts can also have colors based on type
    if (type === 'info') {
      backgroundColor = '#17a2b8'; // Blue for info
    } else if (type === 'warning') {
      backgroundColor = '#ffc107'; // Yellow for warning  
    } else if (type === 'error') {
      backgroundColor = '#dc3545'; // Red for error
    }
  }
  
  // 🚀 PERFORMANCE: Batch style changes with Object.assign
  Object.assign(toast.style, {
    display: 'block',
    opacity: '1',
    transform: 'translateX(-50%) translateY(0)',
    backgroundColor: backgroundColor,
    whiteSpace: 'normal'
  });
  toast.title = 'Click to keep visible';
  
  console.log(`🔔 Toast: ${message}`);
  
  // Auto-hide unless duration is 0 (persistent)
  if (duration > 0) {
    toastTimeout = setTimeout(() => {
      hideToast();
    }, duration);
  }
}

function updateToastContent(message) {
  const toast = DOM_CACHE.toast;
  if (!toast) return;
  
  // Only update if not persistent
  if (!isPersistentToast) {
    toast.innerText = message;
    lastToastMessage = message;
    toast.style.display = 'block';
    
    // Reset styling for updates
    toast.style.backgroundColor = '#333';
    toast.style.whiteSpace = 'normal';
  }
}

function updateProgressToast(message) {
  // Same as updateToastContent for progress updates
  updateToastContent(message);
}

function hideToast() {
  const toast = DOM_CACHE.toast;
  if (!toast) return;
  
  // Don't hide if persistent
  if (isPersistentToast) return;
  
  // Clear timeout
  if (toastTimeout) {
    clearTimeout(toastTimeout);
    toastTimeout = null;
  }
  
  // 🚀 PERFORMANCE: Batch style changes for hide animation
  Object.assign(toast.style, {
    opacity: '0',
    transform: 'translateX(-50%) translateY(20px)'
  });
  
  setTimeout(() => {
    if (!isPersistentToast) {
      toast.style.display = 'none';
      delete toast._transferData;
    }
  }, 300);
}

// 💾 File Metadata Storage
function storeFileMetadata(files, totalSize) {
  try {
    const metadata = JSON.parse(localStorage.getItem('fileMetadata') || '{}');
    const timestamp = Date.now();
    
    // 🚀 PERFORMANCE: Efficient iteration without Array.from
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      metadata[file.name] = {
        size: file.size,
        timestamp: timestamp,
        lastModified: file.lastModified,
        type: file.type || 'unknown'
      };
    }
    
    localStorage.setItem('fileMetadata', JSON.stringify(metadata));
    console.log(`💾 Stored metadata for ${files.length} files`);
  } catch (e) {
    console.log('⚠️ Failed to store file metadata:', e);
  }
}

// 📊 Transfer Statistics Logging - Device-Specific Session Storage
function saveStatsToLog(stats) {
  try {
    // Save to device-specific session storage (clears when session ends)
    saveToDeviceUploadHistory(stats);
    
    // Also maintain backward compatibility with localStorage for global stats (optional)
    const logs = JSON.parse(localStorage.getItem('transferLogs') || '[]');
    logs.unshift(stats); // Add to beginning
    
    // Keep only last 50 logs in global storage
    if (logs.length > 50) {
      logs.splice(50);
    }
    
    localStorage.setItem('transferLogs', JSON.stringify(logs));
    console.log(`📊 Saved transfer stats to device session:`, stats.type, stats.size, stats.time);
  } catch (e) {
    console.log('⚠️ Failed to save transfer stats:', e);
  }
}

// 🌐 Download Options Management
function showDownloadOptions(event) {
  event.preventDefault();
  
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.5);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10000;
  `;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: white;
    border-radius: 15px;
    padding: 2rem;
    max-width: 500px;
    margin: 1rem;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    text-align: center;
  `;
  
  dialog.innerHTML = `
    <h3 style="margin-top: 0; color: #333;">Choose Download Method</h3>
    <p style="color: var(--text-color); opacity: 0.7; margin-bottom: 2rem;">How would you like to download all files?</p>
    
    <div style="display: flex; gap: 1rem; justify-content: center; flex-wrap: wrap;">
      <button onclick="downloadAsZip()" style="
        background: #4a90e2;
        color: white;
        border: none;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1rem;
        min-width: 180px;
      ">
        📦 Download as ZIP
        <br><small style="opacity: 0.8;">Single compressed file</small>
      </button>
      
      <button onclick="downloadIndividually()" style="
        background: #27ae60;
        color: white;
        border: none;
        padding: 1rem 1.5rem;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1rem;
        min-width: 180px;
      ">
        📄 Download Separately
        <br><small style="opacity: 0.8;">Individual files</small>
      </button>
    </div>
    
    <button onclick="closeDownloadModal()" style="
      background: #e74c3c;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 1.5rem;
      font-size: 0.9rem;
    ">
      Cancel
    </button>
  `;
  
  modal.appendChild(dialog);
  document.body.appendChild(modal);
  
  // Store modal reference for cleanup
  window.currentDownloadModal = modal;
  
  // Close on background click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeDownloadModal();
    }
  });
  
  // Close on Escape key
  document.addEventListener('keydown', function escapeHandler(e) {
    if (e.key === 'Escape') {
      closeDownloadModal();
      document.removeEventListener('keydown', escapeHandler);
    }
  });
}

function downloadAsZip() {
  closeDownloadModal();
  showToast('📦 Preparing ZIP download...', 3000);
  
  // Navigate to the ZIP download
  window.location.href = '/download-all';
}

async function downloadIndividually() {
  closeDownloadModal();
  
  try {
    // Get list of files from the current page
    const fileCards = document.querySelectorAll('.file-card .file-name');
    const fileNames = Array.from(fileCards).map(card => card.textContent.trim());
    
    if (fileNames.length === 0) {
      showToast('❌ No files found to download', 3000);
      return;
    }
    
    showToast(`📄 Starting intelligent sequential download of ${fileNames.length} files (waits for each download to complete)...`, 0);
    
    let downloadCount = 0;
    let failedDownloads = [];
    
    // Smart download completion detection function
    async function waitForDownloadCompletion(fileName, timeoutMs = 15000) {
      return new Promise((resolve) => {
        const startTime = Date.now();
        let resolved = false;
        let visibilityHandler, blurHandler, focusHandler;
        
        const cleanup = () => {
          if (visibilityHandler) document.removeEventListener('visibilitychange', visibilityHandler);
          if (blurHandler) window.removeEventListener('blur', blurHandler);
          if (focusHandler) window.removeEventListener('focus', focusHandler);
        };
        
        const resolveOnce = (method) => {
          if (!resolved) {
            resolved = true;
            cleanup();
            resolve(method);
          }
        };
        
        // Method 1: Immediate visibility change detection (Chrome/Edge)
        if (navigator.userAgent.includes('Chrome') || navigator.userAgent.includes('Edge')) {
          visibilityHandler = () => {
            if (!resolved && Date.now() - startTime > 300) { // Reduced from 1000ms to 300ms
              resolveOnce('visibility-change');
            }
          };
          document.addEventListener('visibilitychange', visibilityHandler);
        }
        
        // Method 2: Fast focus/blur detection (works on most browsers)
        let focusLost = false;
        blurHandler = () => {
          focusLost = true;
        };
        focusHandler = () => {
          if (focusLost && !resolved && Date.now() - startTime > 200) { // Reduced from 1000ms to 200ms
            resolveOnce('focus-detection');
          }
        };
        window.addEventListener('blur', blurHandler);
        window.addEventListener('focus', focusHandler);
        
        // Method 3: Ultra-fast adaptive timeout based on actual download behavior
        const adaptiveTimeout = Math.max(800, Math.min(3000, fileNames.length * 400)); // 0.8-3 seconds (was 2-10 seconds)
        
        setTimeout(() => {
          resolveOnce('adaptive-timeout');
        }, adaptiveTimeout);
        
        // Method 4: Quick fallback timeout (reduced from 30s to 15s)
        setTimeout(() => {
          resolveOnce('fallback-timeout');
        }, timeoutMs);
        
        // Method 5: NEW - Network idle detection for very fast completion
        let networkRequests = 0;
        let originalFetch = null;
        
        if (!window._fetchIntercepted) {
          originalFetch = window.fetch;
          window.fetch = function(...args) {
            networkRequests++;
            return originalFetch.apply(this, args).finally(() => {
              networkRequests--;
              if (networkRequests === 0 && Date.now() - startTime > 100) {
                setTimeout(() => {
                  if (networkRequests === 0 && !resolved && Date.now() - startTime > 500) {
                    resolveOnce('network-idle');
                  }
                }, 200);
              }
            });
          };
          window._fetchIntercepted = true;
        }
        
        // Restore original fetch when done
        setTimeout(() => {
          if (originalFetch && window._fetchIntercepted) {
            window.fetch = originalFetch;
            window._fetchIntercepted = false;
          }
        }, timeoutMs + 1000);
      });
    }
    
    // Download each file and wait for completion
    for (let i = 0; i < fileNames.length; i++) {
      try {
        const fileName = fileNames[i];
        updateToastContent(`📄 Downloading ${fileName}... (${downloadCount + 1}/${fileNames.length})`);
        
        // Create and trigger download
        const link = document.createElement('a');
        link.href = `/download/${encodeURIComponent(fileName)}`;
        link.download = fileName;
        link.style.display = 'none';
        document.body.appendChild(link);
        
        const downloadStartTime = Date.now();
        link.click();
        document.body.removeChild(link);
        
        // Wait for download completion with intelligent detection
        updateToastContent(`📄 ${fileName} downloading... waiting for completion (${downloadCount + 1}/${fileNames.length})`);
        
        const completionMethod = await waitForDownloadCompletion(fileName);
        const downloadTime = ((Date.now() - downloadStartTime) / 1000).toFixed(1);
        
        downloadCount++;
        
        console.log(`✅ Download ${downloadCount}: ${fileName} completed via ${completionMethod} in ${downloadTime}s`);
        updateToastContent(`✅ ${fileName} completed (${downloadCount}/${fileNames.length}) • ${downloadTime}s`);
        
        // Minimal pause between downloads for browser stability (reduced from 500ms to 200ms)
        if (i < fileNames.length - 1) { // Don't wait after the last file
          await new Promise(resolve => setTimeout(resolve, 200));
        }
        
      } catch (error) {
        console.error(`Failed to download ${fileNames[i]}:`, error);
        failedDownloads.push(fileNames[i]);
      }
    }
    
    // Final status with timing information
    if (failedDownloads.length === 0) {
      showToast(`✅ Successfully downloaded all ${downloadCount} files with intelligent completion detection!`, 5000);
    } else {
      showToast(`⚠️ Downloaded ${downloadCount} files. Failed: ${failedDownloads.length} (${failedDownloads.join(', ')})`, 8000);
    }
    
  } catch (error) {
    console.error('Individual download error:', error);
    showToast('❌ Error during individual downloads', 5000);
  }
}

function closeDownloadModal() {
  const modal = window.currentDownloadModal;
  if (modal) {
    modal.remove();
    window.currentDownloadModal = null;
  }
}

// Make functions globally available
window.downloadAsZip = downloadAsZip;
window.downloadIndividually = downloadIndividually;
window.closeDownloadModal = closeDownloadModal;

// 📡 Enhanced QR Code Generation for Connection Info - Offline-First
function generateQRCode(text, size = 200) {
  // Use larger QR for better visibility, but still optimized for guests
  const isGuest = typeof detectGuestDevice === 'function' && detectGuestDevice();
  const qrSize = isGuest ? 180 : size;
  
  // Primary: Use our offline QR generator (works without internet)
  const offlineQR = `/api/qr-code?text=${encodeURIComponent(text)}&size=${qrSize}`;
  
  // Fallback services (only if offline generator fails)
  const fallbackServices = [
    `https://quickchart.io/qr?text=${encodeURIComponent(text)}&size=${qrSize}&format=png&margin=1`,
    `https://api.qrserver.com/v1/create-qr-code/?size=${qrSize}x${qrSize}&data=${encodeURIComponent(text)}&margin=10&format=png`,
  ];
  
  return {
    primary: offlineQR,
    fallbacks: fallbackServices,
    // For backward compatibility, return the offline URL directly
    toString: () => offlineQR
  };
}

// 🚀 Preload QR code image as soon as the page loads for instant display
document.addEventListener('DOMContentLoaded', function() {
  // Get the URL to encode (same as used in showConnectionInfo)
  let protocol = location.protocol;
  let hostname = location.hostname;
  let port = location.port;
  if (hostname === 'localhost' || hostname === '127.0.0.1') {
    // Try to get network info including mDNS from server (async, fallback to hostname)
    fetch('/api/network-info').then(response => response.json()).then(networkInfo => {
      let useHostname = hostname;
      
      // Prefer mDNS if available, otherwise use LAN IP
      if (networkInfo.mdns && networkInfo.mdns.status === 'active' && networkInfo.hybrid_url) {
        // Use the full hybrid URL which includes mDNS domain if available
        preloadQRFromUrl(networkInfo.hybrid_url);
      } else if (networkInfo.lan_ip && networkInfo.lan_ip !== '127.0.0.1') {
        useHostname = networkInfo.lan_ip;
        preloadQR(protocol, useHostname, port);
      } else {
        preloadQR(protocol, hostname, port);
      }
    }).catch(() => {
      preloadQR(protocol, hostname, port);
    });
  } else {
    preloadQR(protocol, hostname, port);
  }

  // Start real-time mDNS monitoring for instant updates and toast notifications
  updateMDNSStatus();
  setInterval(updateMDNSStatus, 2000);
  
  function preloadQRFromUrl(fullUrl) {
    const isGuest = typeof detectGuestDevice === 'function' && detectGuestDevice();
    const qrSize = isGuest ? 180 : 200;
    const qrUrl = `/api/qr-code?text=${encodeURIComponent(fullUrl)}&size=${qrSize}`;
    
    // Test if QR API is available with a timeout
    const testImg = new window.Image();
    const timeout = setTimeout(() => {
      console.log('QR API is slow/unavailable, will use offline generation');
      window._qrApiUnavailable = true;
    }, 1000); // 1 second timeout
    
    testImg.onload = () => {
      clearTimeout(timeout);
      window._preloadedQR = {
        url: qrUrl,
        img: testImg,
        timestamp: Date.now()
      };
      console.log('QR API is working, QR preloaded successfully');
    };
    
    testImg.onerror = () => {
      clearTimeout(timeout);
      console.log('QR API failed, will use offline generation');
      window._qrApiUnavailable = true;
    };
    
    testImg.src = qrUrl;
  }
  function preloadQR(protocol, hostname, port) {
    let fullUrl = `${protocol}//${hostname}`;
    if (port && port !== '80' && port !== '443') {
      fullUrl += `:${port}`;
    }
    const isGuest = typeof detectGuestDevice === 'function' && detectGuestDevice();
    const qrSize = isGuest ? 180 : 200;
    const qrUrl = `/api/qr-code?text=${encodeURIComponent(fullUrl)}&size=${qrSize}`;
    
    // Test if QR API is available with a timeout
    const testImg = new window.Image();
    const timeout = setTimeout(() => {
      console.log('QR API is slow/unavailable, will use offline generation');
      window._qrApiUnavailable = true;
    }, 1000); // 1 second timeout
    
    testImg.onload = () => {
      clearTimeout(timeout);
      window._preloadedQR = {
        url: qrUrl,
        img: testImg,
        timestamp: Date.now()
      };
      console.log('QR API is working, QR preloaded successfully');
    };
    
    testImg.onerror = () => {
      clearTimeout(timeout);
      console.log('QR API failed, will use offline generation');
      window._qrApiUnavailable = true;
    };
    
    testImg.src = qrUrl;
  }
});

// 🌐 Enhanced offline QR code generator (backup method)
// 🔗 Enhanced LAN IP and show connection info modal with mDNS support
async function showConnectionInfo() {
  // Get current URL info but FORCE LAN IP or mDNS instead of localhost
  const protocol = location.protocol;
  let hostname = location.hostname;
  const port = location.port;
  let useMDNS = false;
  let mdnsUrl = null;
  let networkInfo = null;
  let lanIpUrl = null;
  
  // 🔧 ALWAYS fetch network info to check for mDNS availability
  try {
    const response = await fetch('/api/network-info');
    if (response.ok) {
      networkInfo = await response.json();
      console.log('📡 Network info received:', networkInfo);
      
      // Use backend-provided LAN IP URL for consistency
      if (networkInfo.lan_ip_url) {
        lanIpUrl = networkInfo.lan_ip_url;
      }
      
      // Prefer mDNS if available
      if (networkInfo.mdns && networkInfo.mdns.status === 'active' && networkInfo.mdns.domain) {
        hostname = networkInfo.mdns.domain;
        useMDNS = true;
        mdnsUrl = networkInfo.hybrid_url;
        console.log('✅ mDNS detected:', networkInfo.mdns.domain, 'URL:', networkInfo.hybrid_url);
      } else {
        // Use current hostname if mDNS not available
        if (hostname === 'localhost' || hostname === '127.0.0.1') {
          // Fallback to LAN IP for localhost access
          if (networkInfo.lan_ip && networkInfo.lan_ip !== '127.0.0.1') {
            hostname = networkInfo.lan_ip;
          }
        }
        console.log('⚠️ mDNS not available, using hostname:', hostname);
      }
    } else {
      console.log('❌ Failed to fetch network info:', response.status);
    }
  } catch (error) {
    console.log('❌ Network info fetch error:', error);
  }
  
  const isHTTPS = protocol === 'https:';
  
  // Construct URL with proper hostname (mDNS or LAN IP)
  let fullUrl;
  if (useMDNS && mdnsUrl) {
    fullUrl = mdnsUrl;
  } else {
    fullUrl = `${protocol}//${hostname}`;
    if (port && port !== '80' && port !== '443') {
      fullUrl += `:${port}`;
    }
  }
  
  // Store network info globally for copy functions
  window._currentNetworkInfo = { networkInfo, lanIpUrl, useMDNS, fullUrl };
  
  // Debug logging
  console.log('🔍 Connection Info Debug:', {
    useMDNS: useMDNS,
    fullUrl: fullUrl,
    mdnsUrl: mdnsUrl,
    lanIpUrl: lanIpUrl,
    networkInfo: networkInfo
  });
  
  // Create modal with immediate QR loading
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    box-sizing: border-box;
  `;
  
  const dialog = document.createElement('div');
  dialog.style.cssText = `
    background: white;
    border-radius: 15px;
    width: 90%;
    max-width: 500px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    margin: 0 auto;
    padding: 2rem;
  `;
  
  // 🚀 ENHANCED: Offline-first QR generation for reliability
  const isGuest = typeof detectGuestDevice === 'function' && detectGuestDevice();
  const qrSize = isGuest ? 180 : 200;
  
  // Use our offline QR generator as primary
  const qrResult = generateQRCode(fullUrl, qrSize);
  const primaryQRUrl = qrResult.primary || qrResult.toString();
  const fallbackQRUrls = qrResult.fallbacks || [
    `https://quickchart.io/qr?text=${encodeURIComponent(fullUrl)}&size=${qrSize}&format=png&margin=1`,
    `https://api.qrserver.com/v1/create-qr-code/?size=${qrSize}x${qrSize}&data=${encodeURIComponent(fullUrl)}&margin=10&format=png`,
  ];
  
  // If preloaded QR matches, use it instantly, otherwise use offline generator
  setTimeout(() => {
    const primaryQR = document.getElementById('qr-primary');
    if (primaryQR) {
      // Check if QR API was determined to be unavailable during preload
      if (window._qrApiUnavailable) {
        console.log('QR API unavailable, using offline generation immediately');
        // Use requestIdleCallback to prevent blocking during uploads
        if (window.requestIdleCallback) {
          requestIdleCallback(() => showOfflineQR());
        } else {
          setTimeout(showOfflineQR, 100);
        }
        return;
      }
      
      if (window._preloadedQR && window._preloadedQR.url === primaryQRUrl) {
        primaryQR.src = window._preloadedQR.img.src;
      } else {
        primaryQR.src = primaryQRUrl; // This will use our offline generator
      }
      
      // Aggressive fallback - if QR doesn't load quickly, try offline immediately
      setTimeout(() => {
        if (primaryQR.style.display === 'none') {
          console.log('QR API not responding quickly, trying offline generator immediately...');
          // Use async to prevent blocking uploads
          if (window.requestIdleCallback) {
            requestIdleCallback(() => showOfflineQR());
          } else {
            setTimeout(showOfflineQR, 50);
          }
        }
      }, 800); // Further reduced timeout
      
      // Second fallback - try external service
      setTimeout(() => {
        if (primaryQR.style.display === 'none') {
          console.log('Primary QR failed, trying external fallback...');
          const fallbackQR = document.getElementById('qr-fallback');
          if (fallbackQR && fallbackQRUrls.length > 0) {
            fallbackQR.src = fallbackQRUrls[0];
            // Final fallback to offline if external also fails
            setTimeout(() => {
              if (fallbackQR.style.display === 'none') {
                console.log('All external QR services failed, forcing offline...');
                if (window.requestIdleCallback) {
                  requestIdleCallback(() => showOfflineQR());
                } else {
                  setTimeout(showOfflineQR, 50);
                }
              }
            }, 800);
          }
        }
      }, 2000); // Try external after 2 seconds if local still hasn't loaded
    }
  }, 10);
  
  const lanInstructions = (location.hostname === 'localhost' || location.hostname === '127.0.0.1') && hostname === location.hostname ? `
    <div style="background: #fff3cd; border: 1px solid #ffeaa7; padding: 1rem; border-radius: 8px; margin: 1rem 0;">
      <h4 style="margin: 0 0 0.5rem 0; color: #856404;">🔍 To share on LAN:</h4>
      <p style="margin: 0; font-size: 0.9rem; color: #856404;">
        • Replace "localhost" with your computer's IP address<br>
        • Windows: Run <code>ipconfig</code> and look for IPv4<br>
        • Linux/Mac: Run <code>ip addr</code> or <code>ifconfig</code><br>
        • Android Termux: Run <code>ip route | grep default</code>
      </p>
    </div>
  ` : '';
  
  dialog.innerHTML = `
    <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 1rem;">
      <h3 style="margin: 0; color: #333; display: flex; align-items: center; gap: 0.5rem;">
        <span>${isHTTPS ? '🔒' : '🌐'}</span>
        Connection Info
      </h3>
      <button onclick="closeConnectionModal()" style="background: #e74c3c; color: white; border: none; padding: 0.5rem 1rem; border-radius: 6px; cursor: pointer; font-size: 0.9rem;">✕ Close</button>
    </div>
    
    <div style="margin: 1.5rem 0;">
      <!-- QR Code Container with Immediate Loading -->
      <div id="qr-container" style="text-align: center; min-height: 220px; position: relative;">
        <!-- Primary QR Code -->
     <img id="qr-primary" 
       style="display: none; border: 2px solid #e1e1e1; border-radius: 10px; max-width: 180px; height: auto; margin: 0 auto;"
       onload="showQRSuccess(this, 'primary')"
       onerror="showOfflineQR()">
     <!-- Fallback QR Code (skip for guest devices, use offline QR instantly) -->
     <img id="qr-fallback" 
       style="display: none; border: 2px solid #e1e1e1; border-radius: 10px; max-width: 180px; height: auto; margin: 0 auto;"
       onload="showQRSuccess(this, 'fallback')"
       onerror="showOfflineQR()">
        
        <!-- Loading Animation -->
        <div id="qr-loading" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);">
          <div style="width: 40px; height: 40px; border: 4px solid var(--border-color); border-top: 4px solid #007bff; border-radius: 50%; animation: qr-spin 1s linear infinite; margin-bottom: 1rem;"></div>
          <p style="margin: 0; color: var(--text-color); opacity: 0.8; font-size: 0.9rem;">🔄 Generating QR Code...</p>
        </div>
        
        <!-- Offline QR Fallback -->
        <canvas id="offline-qr" style="display: none; border: 2px solid #e1e1e1; border-radius: 10px; margin: 0 auto;"></canvas>
        <p id="offline-qr-text" style="display: none; font-size: 0.8rem; color: var(--text-color); opacity: 0.8; margin-top: 0.5rem;">📱 Offline QR Code</p>
      </div>
    </div>
    
    <div style="background: var(--input-bg); border-radius: 10px; padding: 1rem; margin: 1rem 0; border: 1px solid var(--border-color);">
      ${useMDNS ? `
        <h4 style="margin: 0 0 0.5rem 0; color: var(--text-color);">🌐 mDNS Connection URL:</h4>
        <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; margin-bottom: 1rem;">
          <code id="connection-url" style="flex: 1; background: #d4edda; padding: 0.5rem; border-radius: 5px; border: 1px solid #c3e6cb; font-size: 0.85rem; word-break: break-all; min-width: 200px; color: #155724;">${fullUrl}</code>
          <button onclick="copyConnectionUrl()" style="background: #28a745; color: white; border: none; padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer; font-size: 0.85rem; white-space: nowrap;" title="Copy mDNS URL to clipboard">📋 Copy</button>
        </div>
        <div style="padding: 0.6rem; background: #d4edda; border: 1px solid #c3e6cb; border-radius: 6px; margin-bottom: 0.8rem;">
          <small style="color: #155724; display: flex; align-items: center; gap: 0.3rem; font-size: 0.8rem;">
            <span>✅</span>
            <strong>mDNS Active:</strong> Easy access via domain name - guests can use ${networkInfo?.mdns?.domain || 'lanvan.local'}!
          </small>
        </div>
        <h4 style="margin: 0 0 0.5rem 0; color: var(--text-color); opacity: 0.8; font-size: 0.9rem;">📱 Alternative IP Connection:</h4>
        <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap; margin-bottom: 0.8rem;">
          <code id="alternative-url" style="flex: 1; background: var(--section-bg); color: var(--text-color); padding: 0.4rem; border-radius: 5px; border: 1px solid var(--border-color); font-size: 0.8rem; word-break: break-all; min-width: 200px;">${lanIpUrl || 'http://192.168.x.x'}</code>
          <button onclick="copyAlternativeUrl()" style="background: var(--settings-bg); color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 5px; cursor: pointer; font-size: 0.8rem; white-space: nowrap;" title="Copy IP URL to clipboard">📋 Copy</button>
        </div>
        
        <!-- IP QR Code Section -->
        <div style="text-align: center; margin: 1rem 0; padding: 1rem; background: var(--input-bg); border-radius: 8px; border: 1px solid var(--border-color);">
          <div style="margin-bottom: 0.5rem;">
            <small style="color: var(--text-color); opacity: 0.8; font-size: 0.8rem; font-weight: 500;">📱 IP Access QR Code</small>
          </div>
          <img src="/api/qr-code?text=${encodeURIComponent(lanIpUrl || 'http://192.168.0.106')}&size=160" 
               style="border: 2px solid var(--border-color); border-radius: 8px; max-width: 160px; height: auto; background: var(--section-bg);" 
               alt="IP QR Code"
               onerror="this.style.display='none'; this.nextElementSibling.style.display='block';"
               onload="this.style.display='block';">
          <div style="display: none; padding: 0.5rem; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 5px; color: var(--text-color); opacity: 0.8; font-size: 0.8rem;">
            QR code generation failed
          </div>
          <div style="margin-top: 0.5rem;">
            <small style="color: var(--text-color); opacity: 0.7; font-size: 0.75rem;">Scan if mDNS doesn't work</small>
          </div>
        </div>
        <div style="margin-top: 0.5rem;">
          <small style="color: #666; font-size: 0.75rem;">
            💡 <strong>For guests:</strong> Try mDNS first (${networkInfo?.mdns?.domain || 'lanvan.local'}), use IP if that fails
          </small>
        </div>
      ` : `
        <h4 style="margin: 0 0 0.5rem 0; color: var(--text-color);">🔗 Connection URL:</h4>
        <div style="display: flex; gap: 0.5rem; align-items: center; flex-wrap: wrap;">
          <code id="connection-url" style="flex: 1; background: var(--input-bg); color: var(--text-color); padding: 0.5rem; border-radius: 5px; border: 1px solid var(--border-color); font-size: 0.85rem; word-break: break-all; min-width: 200px;">${fullUrl}</code>
          <button onclick="copyConnectionUrl()" style="background: #007bff; color: white; border: none; padding: 0.5rem 1rem; border-radius: 5px; cursor: pointer; font-size: 0.85rem; white-space: nowrap;" title="Copy URL to clipboard">📋 Copy</button>
        </div>
        <div style="margin-top: 0.8rem; padding: 0.6rem; background: var(--input-bg); border: 1px solid var(--border-color); border-radius: 6px;">
          <small style="color: var(--text-color); opacity: 0.8; display: flex; align-items: center; gap: 0.3rem; font-size: 0.8rem;">
            <span>⚠️</span>
            <strong>Using IP Address:</strong> mDNS not available - guests must use IP to connect
          </small>
        </div>
      `}
    </div>
    
    ${lanInstructions}
  `;
  
  modal.appendChild(dialog);
  document.body.appendChild(modal);
  
  // Store modal reference
  window.currentConnectionModal = modal;
  
  // 🚀 IMMEDIATE QR Loading with Smart Fallback System
  setTimeout(() => {
    const primaryQR = document.getElementById('qr-primary');
    if (primaryQR) {
      primaryQR.src = primaryQRUrl;
      // For guest devices, if not loaded in 1s, show offline QR immediately
      if (isGuest) {
        setTimeout(() => {
          if (primaryQR.style.display === 'none') {
            showOfflineQR();
          }
        }, 1000);
      }
    }
  }, 10); // Even smaller delay for instant QR
  
  // Close on background click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeConnectionModal();
    }
  });
  
  // Close on Escape key
  document.addEventListener('keydown', function escapeHandler(e) {
    if (e.key === 'Escape') {
      closeConnectionModal();
      document.removeEventListener('keydown', escapeHandler);
    }
  });
}

// 📋 Copy connection URL to clipboard
async function copyConnectionUrl() {
  const urlElement = document.getElementById('connection-url');
  if (!urlElement) return;
  
  const url = urlElement.textContent;
  
  try {
    // Modern clipboard API
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(url);
      showToast('📋 Connection URL copied to clipboard!', 3000);
    } else {
      // Fallback for older browsers or HTTP
      const textArea = document.createElement('textarea');
      textArea.value = url;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      showToast('📋 Connection URL copied to clipboard!', 3000);
    }
  } catch (err) {
    console.error('Copy failed:', err);
    showToast('❌ Copy failed. Please copy manually.', 4000);
  }
}

// 📋 Copy alternative IP URL to clipboard
async function copyAlternativeUrl() {
  const urlElement = document.getElementById('alternative-url');
  if (!urlElement) {
    // Fallback to stored network info
    const networkInfo = window._currentNetworkInfo;
    if (networkInfo && networkInfo.lanIpUrl) {
      try {
        if (navigator.clipboard && window.isSecureContext) {
          await navigator.clipboard.writeText(networkInfo.lanIpUrl);
          showToast('📋 Alternative IP URL copied to clipboard!', 3000);
        } else {
          const textArea = document.createElement('textarea');
          textArea.value = networkInfo.lanIpUrl;
          textArea.style.position = 'fixed';
          textArea.style.opacity = '0';
          document.body.appendChild(textArea);
          textArea.focus();
          textArea.select();
          document.execCommand('copy');
          document.body.removeChild(textArea);
          showToast('📋 Alternative IP URL copied to clipboard!', 3000);
        }
      } catch (err) {
        console.error('Copy failed:', err);
        showToast('❌ Copy failed. Please copy manually.', 4000);
      }
    }
    return;
  }
  
  const url = urlElement.textContent;
  
  try {
    // Modern clipboard API
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(url);
      showToast('📋 Alternative IP URL copied to clipboard!', 3000);
    } else {
      // Fallback for older browsers or HTTP
      const textArea = document.createElement('textarea');
      textArea.value = url;
      textArea.style.position = 'fixed';
      textArea.style.opacity = '0';
      document.body.appendChild(textArea);
      textArea.focus();
      textArea.select();
      document.execCommand('copy');
      document.body.removeChild(textArea);
      showToast('📋 Alternative IP URL copied to clipboard!', 3000);
    }
  } catch (err) {
    console.error('Copy failed:', err);
    showToast('❌ Copy failed. Please copy manually.', 4000);
  }
}

// � Show IP QR Code in a popup
function showIPQRCode() {
  const networkInfo = window._currentNetworkInfo;
  if (!networkInfo || !networkInfo.lanIpUrl) {
    showToast('❌ IP URL not available', 3000);
    return;
  }
  
  // Create QR popup modal
  const qrModal = document.createElement('div');
  qrModal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.8);
    z-index: 10001;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    box-sizing: border-box;
  `;
  
  const qrDialog = document.createElement('div');
  qrDialog.style.cssText = `
    background: white;
    border-radius: 15px;
    padding: 2rem;
    text-align: center;
    max-width: 400px;
    width: 90%;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
  `;
  
  qrDialog.innerHTML = `
    <h3 style="margin: 0 0 1rem 0; color: #333;">📱 IP Access QR Code</h3>
    <div style="margin: 1rem 0;">
      <img src="https://quickchart.io/qr?text=${encodeURIComponent(networkInfo.lanIpUrl)}&size=200&format=png&margin=1" 
           style="border: 2px solid #ddd; border-radius: 10px; max-width: 200px; height: auto;" 
           alt="IP QR Code">
    </div>
    <p style="margin: 0.5rem 0; font-size: 0.9rem; color: #666; word-break: break-all;">
      ${networkInfo.lanIpUrl}
    </p>
    <div style="margin-top: 1.5rem;">
      <button onclick="this.closest('.qr-modal').remove()" 
              style="background: var(--settings-bg); color: white; border: none; padding: 0.5rem 1.5rem; border-radius: 8px; cursor: pointer; font-size: 0.9rem;">
        Close
      </button>
    </div>
  `;
  
  qrModal.className = 'qr-modal';
  qrModal.appendChild(qrDialog);
  
  // Close on background click
  qrModal.addEventListener('click', (e) => {
    if (e.target === qrModal) {
      qrModal.remove();
    }
  });
  
  document.body.appendChild(qrModal);
  
  showToast('📱 IP QR Code displayed', 2000);
}

// �🚪 Close connection info modal
function closeConnectionModal() {
  const modal = window.currentConnectionModal;
  if (modal) {
    modal.remove();
    window.currentConnectionModal = null;
  }
}

// 🌐 Update mDNS status in protocol indicator
async function updateMDNSStatus() {
  try {
    const response = await fetch('/api/network-info');
    if (response.ok) {
      const networkInfo = await response.json();
      
      // Check if mDNS status changed
      const previousStatus = window._lastMDNSStatus;
      const currentStatus = networkInfo.mdns?.status || 'disabled';
      
      // Update stored status
      window._lastMDNSStatus = currentStatus;
      
      // Show toast notification on status change
      if (previousStatus && previousStatus !== currentStatus) {
        if (currentStatus === 'active') {
          showToast('🌐 mDNS Active: Guests can use ' + (networkInfo.mdns?.domain || 'lanvan.local'), 4000);
          console.log('✅ mDNS became active:', networkInfo.mdns?.domain);
        } else {
          showToast('⚠️ mDNS Unavailable: Guests must use IP address', 4000);
          console.log('❌ mDNS became unavailable');
        }
        
        // Auto-refresh QR codes and connection info
        refreshConnectionInfo();
      }
      
      // Update protocol status indicator if needed
      const protocolStatus = document.getElementById('protocolStatus');
      if (protocolStatus && currentStatus === 'active') {
        // Add mDNS indicator to protocol status
        const qrHintText = protocolStatus.querySelector('#qrHintText');
        if (qrHintText && !qrHintText.innerHTML.includes('mDNS')) {
          qrHintText.innerHTML = '🌐 mDNS Ready • Click for QR codes';
        }
      }
    }
  } catch (error) {
    console.log('mDNS status check failed:', error);
  }
}

// 🔄 Refresh connection info and QR codes
function refreshConnectionInfo() {
  // Refresh preloaded QR codes
  if (typeof preloadQRFromNetworkInfo === 'function') {
    fetch('/api/network-info')
      .then(response => response.json())
      .then(networkInfo => {
        if (networkInfo.mdns?.status === 'active' && networkInfo.hybrid_url) {
          preloadQRFromUrl(networkInfo.hybrid_url);
          console.log('🔄 QR codes refreshed for mDNS URL:', networkInfo.hybrid_url);
        }
      })
      .catch(() => {});
  }
  
  // If connection modal is open, refresh it
  if (window.currentConnectionModal) {
    window.currentConnectionModal.remove();
    window.currentConnectionModal = null;
    // Small delay then reopen
    setTimeout(() => {
      showConnectionInfo();
    }, 200);
  }
}

// 📡 Real-time mDNS status monitoring with toast notifications
async function updateMDNSStatus() {
  try {
    const response = await fetch('/api/network-info');
    if (response.ok) {
      const networkInfo = await response.json();
      const qrHintText = document.getElementById('qrHintText');
      
      if (networkInfo.mdns && networkInfo.mdns.status === 'active' && qrHintText) {
        const domain = networkInfo.mdns.domain;
        const conflictInfo = networkInfo.mdns.conflict_resolved 
          ? ` (resolved conflict #${networkInfo.mdns.conflict_count + 1})` 
          : '';
        
        // Update QR hint if not already showing mDNS status
        if (!qrHintText.innerHTML.includes('mDNS:')) {
          qrHintText.innerHTML = `🌐 <strong>mDNS:</strong> ${domain}${conflictInfo} • Click for QR`;
          // Use green color that works in both light and dark modes
          qrHintText.style.color = '#22c55e';
          qrHintText.style.setProperty('color', '#22c55e', 'important');
          qrHintText.title = `mDNS service active - accessible via ${domain}`;
          
          // Show success toast
          showToast(`🎉 mDNS service is now active! Accessible via ${domain}${conflictInfo}`, 4000);
          
          // Refresh connection info to update QR codes
          refreshConnectionInfo();
        }
      } else if (qrHintText && qrHintText.innerHTML.includes('mDNS:')) {
        // mDNS was active but now inactive - revert to default
        qrHintText.innerHTML = '• Click for QR code';
        qrHintText.style.color = 'var(--protocol-text)';
        qrHintText.title = '';
        
        // Show info toast
        showToast('ℹ️ mDNS service is not active - using IP address', 3000);
      }
    }
  } catch (error) {
    console.log('Could not fetch mDNS status:', error);
  }
}

// � Enhanced QR Loading Functions
function showQRSuccess(imgElement, type) {
  // Hide loading animation
  const loadingDiv = document.getElementById('qr-loading');
  if (loadingDiv) {
    loadingDiv.style.display = 'none';
  }
  
  // Show successful QR code
  imgElement.style.display = 'block';
  imgElement.classList.add('qr-reveal');
  
  console.log(`✅ QR Code loaded successfully (${type})`);
}

function tryFallbackQR() {
  console.log('⚠️ Primary QR failed, trying fallback...');
  const fallbackQR = document.getElementById('qr-fallback');
  const url = document.getElementById('connection-url').textContent;
  
  if (fallbackQR) {
    fallbackQR.src = `https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=${encodeURIComponent(url)}&margin=10&format=png`;
  }
}

function showOfflineQR() {
  // Skip QR generation if uploads are in progress to prevent UI blocking
  if (window._qrBlocked) {
    console.log('⏸️ QR generation blocked during upload - will retry later');
    setTimeout(() => showOfflineQR(), 1000); // Retry in 1 second
    return;
  }
  
  console.log('⚠️ Using offline QR generator...');
  
  // Hide loading and failed images
  const loadingDiv = document.getElementById('qr-loading');
  const primaryQR = document.getElementById('qr-primary');
  const fallbackQR = document.getElementById('qr-fallback');
  
  if (loadingDiv) loadingDiv.style.display = 'none';
  if (primaryQR) primaryQR.style.display = 'none';
  if (fallbackQR) fallbackQR.style.display = 'none';
  
  // Show offline QR
  const canvas = document.getElementById('offline-qr');
  const text = document.getElementById('offline-qr-text');
  
  if (canvas) {
    canvas.style.display = 'block';
    canvas.width = 200;
    canvas.height = 200;
    
    // Get URL from connection-url element or fallback to current location
    let url;
    const connectionUrl = document.getElementById('connection-url');
    if (connectionUrl) {
      url = connectionUrl.textContent;
    } else {
      // Fallback to current page URL
      url = window.location.href;
    }
    
    try {
      generateOfflineQR(url, canvas);
      canvas.classList.add('qr-reveal');
      console.log('✅ Offline QR generated successfully');
    } catch (error) {
      console.error('❌ Failed to generate offline QR:', error);
      // Show a simple error message in the canvas
      const ctx = canvas.getContext('2d');
      ctx.fillStyle = 'var(--text-color)';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('QR Code', 100, 90);
      ctx.fillText('Generation', 100, 110);
      ctx.fillText('Failed', 100, 130);
    }
  }
  
  if (text) {
    text.style.display = 'block';
  }
}

// �🔄 QR Code Loading Functions
function showQRCode(imgElement) {
  // Hide loading animation
  const loadingDiv = document.getElementById('qr-loading');
  if (loadingDiv) {
    loadingDiv.style.display = 'none';
  }
  
  // Show QR code with proper centering and smooth animation
  imgElement.style.display = 'block';
  imgElement.style.margin = '0 auto';
  imgElement.classList.add('qr-reveal');
  
  console.log('✅ QR Code loaded successfully');
}

function showQRFallback() {
  // Hide loading animation and main QR image
  const loadingDiv = document.getElementById('qr-loading');
  const qrImage = document.getElementById('qr-image');
  const fallbackDiv = document.getElementById('qr-offline-fallback');
  
  if (loadingDiv) loadingDiv.style.display = 'none';
  if (qrImage) qrImage.style.display = 'none';
  if (fallbackDiv) {
    fallbackDiv.style.display = 'block';
    
    // Generate offline QR code
    const canvas = document.getElementById('offline-qr');
    if (canvas) {
      const urlElement = document.getElementById('connection-url');
      const url = urlElement ? urlElement.textContent : window.location.href;
      const offlineQR = generateOfflineQR(url, canvas);
      const ctx = canvas.getContext('2d');
      const img = new Image();
      img.onload = () => {
        ctx.drawImage(img, 0, 0);
        canvas.classList.add('qr-reveal'); // Add animation
      };
      img.src = offlineQR;
    }
  }
  
  console.log('⚠️ QR Code fallback activated - using offline generator');
}

// Make functions globally available
window.showConnectionInfo = showConnectionInfo;
window.copyConnectionUrl = copyConnectionUrl;
window.copyAlternativeUrl = copyAlternativeUrl;
window.showIPQRCode = showIPQRCode;
window.updateMDNSStatus = updateMDNSStatus;
window.refreshConnectionInfo = refreshConnectionInfo;
window.closeConnectionModal = closeConnectionModal;
window.showQRCode = showQRCode;
window.showQRFallback = showQRFallback;
window.showQRSuccess = showQRSuccess;
window.tryFallbackQR = tryFallbackQR;
window.showOfflineQR = showOfflineQR;
window.refreshFileListManually = refreshFileListManually;
window.toggleSettingsMenu = toggleSettingsMenu;
window.cancelAllUploads = cancelAllUploads;
window.clearAllFiles = clearAllFiles;
window.showDownloadOptions = showDownloadOptions;
window.showToast = showToast;
window.toggleDeviceLogs = toggleDeviceLogs;
window.showAccessControlSettings = showAccessControlSettings;
window.downloadAsZip = downloadAsZip;
window.cancelUpload = cancelUpload;
window.downloadDeviceLogs = downloadDeviceLogs;
window.clearDeviceLogs = clearDeviceLogs;
window.closeDeviceLogsModal = closeDeviceLogsModal;
window.removeCompletedUpload = removeCompletedUpload;
window.clearCompletedUploads = clearCompletedUploads;
window.showImagePreview = showImagePreview;
window.uploadClipboardItem = uploadClipboardItem;

// === 📋 CLIPBOARD SYSTEM FUNCTIONS ===

// Clipboard state management
let clipboardHistoryData = [];

// Open clipboard modal
function openClipboardModal() {
  const modal = document.getElementById('clipboardModal');
  modal.style.display = 'flex';
  
  // Load clipboard history
  refreshClipboardHistory();
  
  // Set focus to text input
  setTimeout(() => {
    const textInput = document.getElementById('clipboardTextInput');
    if (textInput) textInput.focus();
  }, 100);
  
  // Close on escape key
  document.addEventListener('keydown', function escapeHandler(e) {
    if (e.key === 'Escape') {
      closeClipboardModal();
      document.removeEventListener('keydown', escapeHandler);
    }
  });
  
  // Close on background click
  modal.addEventListener('click', (e) => {
    if (e.target === modal) {
      closeClipboardModal();
    }
  });
  
  console.log('📋 Clipboard modal opened');
}

// Close clipboard modal
function closeClipboardModal() {
  const modal = document.getElementById('clipboardModal');
  modal.style.display = 'none';
}

// Handle paste events in the text area
function handleClipboardPaste(event) {
  console.log('📋 Paste event detected');
  
  // Get clipboard data
  const clipboardData = event.clipboardData || window.clipboardData;
  
  if (!clipboardData) {
    console.log('📋 No clipboard data available');
    return;
  }
  
  // Check for files/images first (including mobile)
  const files = clipboardData.files;
  if (files && files.length > 0) {
    console.log('📋 Files detected in clipboard:', files.length);
    event.preventDefault();
    
    // Handle each file
    Array.from(files).forEach(file => {
      if (file.type.startsWith('image/')) {
        console.log('🖼️ Image file detected:', file.type);
        handleImagePaste(file);
      } else {
        console.log('📄 Non-image file detected:', file.type);
        showToast('📋 File detected, but only images are supported', 3000);
      }
    });
    return;
  }
  
  // Check for image data in items
  const items = clipboardData.items;
  if (items) {
    for (let i = 0; i < items.length; i++) {
      const item = items[i];
      console.log('📋 Clipboard item type:', item.type);
      
      if (item.type.indexOf('image') !== -1) {
        // Handle image paste
        event.preventDefault();
        const blob = item.getAsFile();
        if (blob) {
          console.log('🖼️ Image blob detected from clipboard items');
          handleImagePaste(blob);
          return;
        }
      }
    }
  }
  
  // Check for text data
  const textData = clipboardData.getData('text/plain');
  if (textData) {
    console.log('📋 Text data detected, length:', textData.length);
    // Let the normal paste proceed for text
  }
  
  console.log('📋 Text paste detected - will be added when you click "Add Text"');
}

// Handle image paste from clipboard
function handleImagePaste(blob) {
  console.log('📋 Image pasted from clipboard, size:', blob.size);
  showToast('🖼️ Processing pasted image...', 2000);
  
  // Create file object
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const filename = `clipboard-image-${timestamp}.png`;
  
  // Add to clipboard via API
  const formData = new FormData();
  formData.append('file', blob, filename);
  
  fetch('/api/clipboard/add', {
    method: 'POST',
    body: formData
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      showToast(`�️ Image added to clipboard: ${filename}`, 3000);
      refreshClipboardHistory();
    } else {
      showToast(`❌ Failed to add image: ${data.msg}`, 4000);
    }
  })
  .catch(error => {
    console.error('Error adding image to clipboard:', error);
    showToast('❌ Failed to add image to clipboard', 4000);
  });
}

// Enhanced image upload function for clipboard with simple naming and better quality
function uploadImageToClipboard(blob) {
  // Get next image number for simple naming
  const imageCount = getClipboardImageCount() + 1;
  const filename = `${imageCount}.png`;
  
  // Add to clipboard via API
  const formData = new FormData();
  formData.append('file', blob, filename);
  
  fetch('/api/clipboard/add', {
    method: 'POST',
    body: formData
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      showToast(`🖼️ Image added to clipboard: ${filename}`, 3000);
      refreshClipboardHistory();
    } else {
      showToast(`❌ Failed to add image: ${data.msg}`, 4000);
    }
  })
  .catch(error => {
    console.error('Error adding image to clipboard:', error);
    showToast('❌ Failed to add image to clipboard', 4000);
  });
}

// Get count of images in clipboard for simple numbering
function getClipboardImageCount() {
  return clipboardHistoryData.filter(item => 
    item.type === 'file' && 
    item.content_type === 'image'
  ).length;
}

// Add text content to clipboard with instant responsiveness
async function addTextToClipboard() {
  const textInput = document.getElementById('clipboardTextInput');
  const addButton = document.getElementById('addTextToClipboardBtn'); // Updated selector
  const text = textInput.value; // Preserve original formatting - no trim()
  
  // Immediate validation with instant feedback
  if (!text || !text.trim()) { // Only check if completely empty
    showToast('❌ Please enter some text to add to clipboard', 3000);
    textInput.focus(); // Immediate focus feedback
    return;
  }

  // Immediate visual feedback - disable button temporarily
  if (addButton) {
    addButton.disabled = true;
    addButton.textContent = '⏳ Adding...';
    addButton.style.opacity = '0.7';
  }

  const formData = new FormData();
  formData.append('data', text);
  
  try {
    // Use setTimeout(0) to ensure this runs completely independently of any upload processing
    setTimeout(async () => {
      try {
        const response = await fetch('/api/clipboard/add', {
          method: 'POST',
          body: formData
        });
        const data = await response.json();
        
        if (data.status === 'success') {
          showToast(`📋 Text added to clipboard (${data.item.size} bytes)`, 3000);
          textInput.value = ''; // Clear input immediately
          
          // Refresh clipboard in next animation frame - completely independent of uploads
          requestAnimationFrame(() => refreshClipboardHistory());
        } else {
          showToast(`❌ Failed to add text: ${data.msg}`, 4000);
        }
      } catch (error) {
        console.error('Error adding text to clipboard:', error);
        showToast('❌ Failed to add text to clipboard', 4000);
      } finally {
        // Restore button state
        if (addButton) {
          addButton.disabled = false;
          addButton.textContent = '📝 Add Text';
          addButton.style.opacity = '1';
        }
      }
    }, 0); // Run in next event loop cycle
    
  } catch (error) {
    console.error('Error adding text to clipboard:', error);
    showToast('❌ Failed to add text to clipboard', 4000);
    // Restore button state on immediate error
    if (addButton) {
      addButton.disabled = false;
      addButton.textContent = '📝 Add Text';
      addButton.style.opacity = '1';
    }
  }
}

// Clear clipboard input fields
function clearClipboardInput() {
  const textInput = document.getElementById('clipboardTextInput');
  
  textInput.value = '';
  
  showToast('🧹 Clipboard input cleared', 2000);
}

// Refresh clipboard history
async function refreshClipboardHistory() {
  try {
    // Use requestIdleCallback if available to avoid blocking upload progress
    const performRefresh = async () => {
      const response = await fetch('/api/clipboard/list');
      const data = await response.json();
      
      if (data.status === 'success') {
        clipboardHistoryData = data.items;
        // Use requestAnimationFrame for smooth UI updates
        requestAnimationFrame(() => renderClipboardHistory(data.items));
      } else {
        console.error('Failed to load clipboard history:', data.msg);
        showToast('❌ Failed to load clipboard history', 3000);
      }
    };
    
    if (window.requestIdleCallback) {
      requestIdleCallback(performRefresh);
    } else {
      await performRefresh();
    }
  } catch (error) {
    console.error('Error loading clipboard history:', error);
    showToast('❌ Failed to load clipboard history', 3000);
  }
}

// Render clipboard history with image previews
function renderClipboardHistory(items) {
  const container = document.getElementById('clipboardHistoryContent');
  
  if (!items.length) {
    container.innerHTML = `
      <div style="text-align: center; color: var(--text-color); padding: 2rem;">
        <div style="font-size: 3rem; margin-bottom: 1rem;">📋</div>
        <div>No clipboard items yet</div>
        <div style="font-size: 0.9rem; margin-top: 0.5rem;">Add content above to get started</div>
      </div>
    `;
    return;
  }
  
  container.innerHTML = items.map(item => {
    const typeIcon = getClipboardItemIcon(item);
    const sizeText = formatClipboardSize(item.size);
    const isImage = item.type === 'file' && item.content_type === 'image';
    
    // Create image preview for image files
    const imagePreview = isImage ? `
      <div style="margin: 0.5rem 0; text-align: center;">
        <img 
          src="/api/clipboard/get/${item.id}" 
          alt="${item.filename}"
          style="
            max-width: 200px; 
            max-height: 150px; 
            border-radius: 4px; 
            border: 1px solid var(--border-color);
            object-fit: cover;
            cursor: pointer;
          "
          onclick="showImagePreview('/api/clipboard/get/${item.id}', '${item.filename}')"
          title="Click to view full size"
        />
      </div>
    ` : '';
    
    return `
      <div style="
        background: var(--section-bg);
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 0.5rem;
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 1rem;
        color: var(--text-color);
      ">
        <div style="flex: 1;">
          <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
            <span style="font-size: 1.2rem;">${typeIcon}</span>
            <strong style="color: var(--text-color);">
              ${item.type === 'file' ? item.filename : `${item.content_type} content`}
            </strong>
            <span style="color: #888; font-size: 0.8rem;">(${sizeText})</span>
          </div>
          ${imagePreview}
          <div style="color: #aaa; font-size: 0.9rem; margin-bottom: 0.5rem;">
            ${isImage ? `Image dimensions and preview above` : item.preview}
          </div>
          <div style="color: #999; font-size: 0.8rem;">
            Added: ${item.timestamp}
          </div>
        </div>
        <div style="display: flex; flex-direction: column; gap: 0.3rem;">
          ${item.type === 'file' ? `
            <button onclick="downloadClipboardItem(${item.id})" style="
              background: #17a2b8;
              color: white;
              border: none;
              padding: 0.3rem 0.6rem;
              border-radius: 4px;
              cursor: pointer;
              font-size: 0.8rem;
            ">📥 Download</button>
          ` : `
            <button onclick="copyClipboardText(${item.id})" style="
              background: #6c5ce7;
              color: white;
              border: none;
              padding: 0.3rem 0.6rem;
              border-radius: 4px;
              cursor: pointer;
              font-size: 0.8rem;
            ">📋 Copy</button>
          `}
          <button onclick="removeClipboardItem(${item.id})" style="
            background: #dc3545;
            color: white;
            border: none;
            padding: 0.3rem 0.6rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
          ">🗑️ Remove</button>
        </div>
      </div>
    `;
  }).join('');
  
  // Apply dark mode colors if currently in dark mode
  if (document.body.hasAttribute('data-theme') && document.body.getAttribute('data-theme') === 'dark') {
    setTimeout(() => {
      fixRemainingColors(true);
    }, 50);
  }
}

// Show full size image preview
function showImagePreview(imageSrc, filename) {
  const modal = document.createElement('div');
  modal.style.cssText = `
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.9);
    z-index: 10002;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 1rem;
    box-sizing: border-box;
    user-select: none;
  `;
  
  let scale = 1;
  let translateX = 0;
  let translateY = 0;
  let isDragging = false;
  let hasDragged = false; // Track if user actually dragged
  let startX = 0;
  let startY = 0;
  let startTranslateX = 0;
  let startTranslateY = 0;
  
  modal.innerHTML = `
    <div style="
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      max-width: 95%;
      max-height: 95%;
    ">
      <!-- Header -->
      <div style="
        padding: 1rem;
        background: rgba(255,255,255,0.95);
        border-radius: 8px 8px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        backdrop-filter: blur(10px);
        flex-shrink: 0;
      ">
        <div style="display: flex; align-items: center; gap: 1rem;">
          <h4 style="margin: 0; color: #333; font-size: 1.1rem;">${filename}</h4>
          <div style="display: flex; gap: 0.5rem; align-items: center;">
            <button class="zoom-btn" onclick="event.stopPropagation(); zoomImage(0.8)" style="
              background: var(--settings-bg);
              color: white;
              border: none;
              padding: 0.4rem 0.8rem;
              border-radius: 4px;
              cursor: pointer;
              font-size: 0.9rem;
            " title="Zoom Out">🔍−</button>
            <span id="zoomLevel" style="color: #666; font-size: 0.9rem; min-width: 50px; text-align: center;">100%</span>
            <button class="zoom-btn" onclick="event.stopPropagation(); zoomImage(1.25)" style="
              background: var(--settings-bg);
              color: white;
              border: none;
              padding: 0.4rem 0.8rem;
              border-radius: 4px;
              cursor: pointer;
              font-size: 0.9rem;
            " title="Zoom In">🔍+</button>
            <button onclick="event.stopPropagation(); resetZoom()" style="
              background: #17a2b8;
              color: white;
              border: none;
              padding: 0.4rem 0.8rem;
              border-radius: 4px;
              cursor: pointer;
              font-size: 0.9rem;
            " title="Reset Zoom">Reset</button>
          </div>
        </div>
        <button onclick="event.stopPropagation(); this.closest('.image-modal').remove()" style="
          background: #dc3545;
          color: white;
          border: none;
          padding: 0.5rem 1rem;
          border-radius: 4px;
          cursor: pointer;
          font-size: 0.9rem;
        ">✕ Close</button>
      </div>
      
      <!-- Image Container -->
      <div class="image-container" style="
        flex: 1;
        background: #000;
        border-radius: 0 0 8px 8px;
        overflow: hidden;
        position: relative;
        cursor: grab;
        display: flex;
        align-items: center;
        justify-content: center;
      ">
        <img id="zoomableImage" src="${imageSrc}" alt="${filename}" style="
          max-width: 100%;
          max-height: 100%;
          object-fit: contain;
          transition: transform 0.2s ease-out;
          transform: scale(1) translate(0px, 0px);
          pointer-events: none;
        " />
        <div class="zoom-instructions" style="
          position: absolute;
          bottom: 10px;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0,0,0,0.7);
          color: white;
          padding: 0.5rem 1rem;
          border-radius: 20px;
          font-size: 0.8rem;
          opacity: 0.8;
        ">
          💡 Double-click to zoom • Drag to pan • Scroll to zoom
        </div>
      </div>
    </div>
  `;
  
  modal.className = 'image-modal';
  document.body.appendChild(modal);
  
  const imageContainer = modal.querySelector('.image-container');
  const image = modal.querySelector('#zoomableImage');
  const zoomLevelDisplay = modal.querySelector('#zoomLevel');
  const instructions = modal.querySelector('.zoom-instructions');
  
  // Hide instructions after 3 seconds
  setTimeout(() => {
    if (instructions) instructions.style.opacity = '0';
  }, 3000);
  
  function updateImageTransform() {
    image.style.transform = `scale(${scale}) translate(${translateX}px, ${translateY}px)`;
    zoomLevelDisplay.textContent = Math.round(scale * 100) + '%';
    
    // Update cursor based on zoom level
    if (scale > 1) {
      imageContainer.style.cursor = isDragging ? 'grabbing' : 'grab';
    } else {
      imageContainer.style.cursor = 'grab';
    }
  }
  
  // Zoom function
  window.zoomImage = function(factor) {
    const newScale = Math.min(Math.max(scale * factor, 0.1), 5); // Min 10%, Max 500%
    
    if (newScale !== scale) {
      scale = newScale;
      
      // Reset pan if zooming out to fit
      if (scale <= 1) {
        translateX = 0;
        translateY = 0;
      }
      
      updateImageTransform();
    }
  };
  
  // Reset zoom function
  window.resetZoom = function() {
    scale = 1;
    translateX = 0;
    translateY = 0;
    updateImageTransform();
  };
  
  // Double-click to zoom (only if not dragging)
  imageContainer.addEventListener('dblclick', (e) => {
    e.preventDefault();
    e.stopPropagation(); // Prevent any parent handlers
    
    // Only zoom if user wasn't dragging
    if (!hasDragged) {
      if (scale === 1) {
        zoomImage(2); // Zoom to 200%
      } else {
        window.resetZoom();
      }
    }
    hasDragged = false; // Reset for next interaction
  });
  
  // Mouse wheel zoom
  imageContainer.addEventListener('wheel', (e) => {
    e.preventDefault();
    const factor = e.deltaY > 0 ? 0.9 : 1.1;
    zoomImage(factor);
  });
  
  // Touch gestures for mobile
  let initialDistance = 0;
  let lastScale = 1;
  
  imageContainer.addEventListener('touchstart', (e) => {
    if (e.touches.length === 2) {
      // Pinch zoom start
      initialDistance = Math.hypot(
        e.touches[0].pageX - e.touches[1].pageX,
        e.touches[0].pageY - e.touches[1].pageY
      );
      lastScale = scale;
      e.preventDefault();
      e.stopPropagation(); // Prevent modal close
    } else if (e.touches.length === 1 && scale > 1) {
      // Single touch pan start
      isDragging = true;
      hasDragged = false; // Reset drag flag
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      startTranslateX = translateX;
      startTranslateY = translateY;
      imageContainer.style.cursor = 'grabbing';
      e.stopPropagation(); // Prevent modal close
    }
  });
  
  imageContainer.addEventListener('touchmove', (e) => {
    if (e.touches.length === 2) {
      // Pinch zoom
      e.preventDefault();
      e.stopPropagation(); // Prevent modal close
      const currentDistance = Math.hypot(
        e.touches[0].pageX - e.touches[1].pageX,
        e.touches[0].pageY - e.touches[1].pageY
      );
      
      if (initialDistance > 0) {
        const newScale = Math.min(Math.max(lastScale * (currentDistance / initialDistance), 0.1), 5);
        scale = newScale;
        updateImageTransform();
      }
    } else if (e.touches.length === 1 && isDragging && scale > 1) {
      // Single touch pan
      e.preventDefault();
      e.stopPropagation(); // Prevent modal close
      const deltaX = e.touches[0].clientX - startX;
      const deltaY = e.touches[0].clientY - startY;
      
      // Check if drag has moved enough to be considered a drag
      if (!hasDragged && (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5)) {
        hasDragged = true;
      }
      
      translateX = startTranslateX + deltaX / scale;
      translateY = startTranslateY + deltaY / scale;
      updateImageTransform();
    }
  });
  
  imageContainer.addEventListener('touchend', (e) => {
    if (e.touches.length === 0) {
      isDragging = false;
      initialDistance = 0;
      updateImageTransform();
    }
  });
  
  // Mouse drag for desktop
  imageContainer.addEventListener('mousedown', (e) => {
    if (scale > 1) {
      isDragging = true;
      hasDragged = false; // Reset drag flag
      startX = e.clientX;
      startY = e.clientY;
      startTranslateX = translateX;
      startTranslateY = translateY;
      imageContainer.style.cursor = 'grabbing';
      e.preventDefault();
      e.stopPropagation(); // Prevent modal close
    }
  });
  
  document.addEventListener('mousemove', (e) => {
    if (isDragging && scale > 1) {
      const deltaX = e.clientX - startX;
      const deltaY = e.clientY - startY;
      
      // If moved more than 5 pixels, consider it a drag
      if (Math.abs(deltaX) > 5 || Math.abs(deltaY) > 5) {
        hasDragged = true;
      }
      
      translateX = startTranslateX + deltaX / scale;
      translateY = startTranslateY + deltaY / scale;
      updateImageTransform();
    }
  });
  
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      updateImageTransform();
    }
  });
  
  // Keyboard shortcuts
  const keyHandler = (e) => {
    if (e.key === 'Escape') {
      modal.remove();
      document.removeEventListener('keydown', keyHandler);
    } else if (e.key === '+' || e.key === '=') {
      e.preventDefault();
      zoomImage(1.25);
    } else if (e.key === '-') {
      e.preventDefault();
      zoomImage(0.8);
    } else if (e.key === '0') {
      e.preventDefault();
      window.resetZoom();
    }
  };
  
  document.addEventListener('keydown', keyHandler);
  
  // Prevent clicks on header and image container from closing modal
  const headerElement = modal.querySelector('div[style*="backdrop-filter"]');
  const imageContainerElement = modal.querySelector('.image-container');
  
  if (headerElement) {
    headerElement.addEventListener('click', (e) => {
      e.stopPropagation();
    });
  }
  
  if (imageContainerElement) {
    imageContainerElement.addEventListener('click', (e) => {
      e.stopPropagation();
    });
  }
  
  // Close on background click (but not when interacting with image)
  modal.addEventListener('click', (e) => {
    // Only close if clicking on the modal background, not on image container or image itself
    if (e.target === modal) {
      modal.remove();
      document.removeEventListener('keydown', keyHandler);
    }
  });
  
  // Clean up when modal is removed
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.removedNodes.forEach((node) => {
        if (node === modal) {
          document.removeEventListener('keydown', keyHandler);
          // Clean up global functions
          delete window.zoomImage;
          delete window.resetZoom;
          observer.disconnect();
        }
      });
    });
  });
  
  observer.observe(document.body, { childList: true });
}

// Upload clipboard item to main file storage
function uploadClipboardItem(itemId) {
  fetch(`/api/clipboard/upload/${itemId}`, {
    method: 'POST'
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      showToast(`✅ Uploaded: ${data.filename}`, 3000);
      refreshFileListManually(); // Refresh the file list to show new file
    } else {
      showToast(`❌ Upload failed: ${data.msg}`, 4000);
    }
  })
  .catch(error => {
    console.error('Error uploading from clipboard:', error);
    showToast('❌ Failed to upload from clipboard', 4000);
  });
}

// Download clipboard item
function downloadClipboardItem(itemId) {
  window.open(`/api/clipboard/get/${itemId}`, '_blank');
}

// Copy clipboard text item to system clipboard
async function copyClipboardText(itemId) {
  try {
    const response = await fetch(`/api/clipboard/get/${itemId}`);
    const data = await response.json();
    
    if (data.status === 'success') {
      // Modern clipboard API
      if (navigator.clipboard && window.isSecureContext) {
        await navigator.clipboard.writeText(data.item.data);
        showToast('📋 Copied to system clipboard', 2000);
      } else {
        // Fallback for older browsers or non-secure contexts
        const textArea = document.createElement('textarea');
        textArea.value = data.item.data;
        textArea.style.position = 'fixed';
        textArea.style.top = '0';
        textArea.style.left = '0';
        textArea.style.width = '2em';
        textArea.style.height = '2em';
        textArea.style.padding = '0';
        textArea.style.border = 'none';
        textArea.style.outline = 'none';
        textArea.style.boxShadow = 'none';
        textArea.style.background = 'transparent';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        
        try {
          const successful = document.execCommand('copy');
          if (successful) {
            showToast('📋 Copied to system clipboard', 2000);
          } else {
            showToast('❌ Failed to copy to system clipboard', 3000);
          }
        } catch (err) {
          console.error('Fallback copy failed:', err);
          showToast('❌ Clipboard API not supported in this browser', 3000);
        }
        
        document.body.removeChild(textArea);
      }
    } else {
      showToast('❌ Failed to copy to system clipboard', 3000);
    }
  } catch (error) {
    console.error('Error copying clipboard text:', error);
    showToast('❌ Failed to copy to system clipboard', 3000);
  }
}

// Remove clipboard item
function removeClipboardItem(itemId) {
  fetch(`/api/clipboard/remove/${itemId}`, {
    method: 'DELETE'
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      showToast('🗑️ Clipboard item removed', 2000);
      refreshClipboardHistory();
    } else {
      showToast(`❌ Failed to remove item: ${data.msg}`, 3000);
    }
  })
  .catch(error => {
    console.error('Error removing clipboard item:', error);
    showToast('❌ Failed to remove clipboard item', 3000);
  });
}

// Download clipboard history as ZIP file with images or text file if no images
async function downloadClipboardHistory() {
  try {
    if (clipboardHistoryData.length === 0) {
      showToast('❌ No clipboard history to download', 3000);
      return;
    }
    
    // Calculate summary statistics efficiently
    let textItems = 0, fileItems = 0, imageItems = 0, totalSizeBytes = 0;
    
    for (const item of clipboardHistoryData) {
      if (item.type === 'text') textItems++;
      if (item.type === 'file') fileItems++;
      if (item.filename && item.filename.includes('clipboard-image')) imageItems++;
      totalSizeBytes += (item.size || 0);
    }
    
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const hasImages = imageItems > 0;
    
    if (hasImages) {
      // Create ZIP file with text report and all images
      showToast('📦 Creating ZIP file with images and text report...', 3000);
      
      const zip = new JSZip();
      
      // Create text report
      const reportParts = [];
      reportParts.push(`LANVAN CLIPBOARD HISTORY REPORT
========================================
Generated: ${new Date().toLocaleString()}
Total Items: ${clipboardHistoryData.length}
Report Format: ZIP Archive with Images

SUMMARY STATISTICS:
- Text Items: ${textItems}
- File Items: ${fileItems} (including ${imageItems} images)
- Total Size: ${formatClipboardSize(totalSizeBytes)}

========================================
DETAILED CLIPBOARD ITEMS:
========================================

`);
      
      // Process items in chunks
      const chunkSize = 5;
      const imagePromises = [];
      
      for (let i = 0; i < clipboardHistoryData.length; i += chunkSize) {
        const chunk = clipboardHistoryData.slice(i, i + chunkSize);
        
        for (const [chunkIndex, item] of chunk.entries()) {
          const index = i + chunkIndex;
          
          let content = 'No content available';
          
          if (item.type === 'text') {
            try {
              const response = await fetch(`/api/clipboard/get/${item.id}`);
              const data = await response.json();
              if (data.status === 'success' && data.item && data.item.data) {
                content = data.item.data;
              } else {
                content = item.preview || 'Failed to fetch full content';
              }
            } catch (error) {
              content = item.preview || 'Error fetching full content';
            }
          } else if (item.type === 'file' && item.filename && item.filename.includes('clipboard-image')) {
            // For images, add to ZIP and reference in report
            content = `Image file: ${item.filename} (${formatClipboardSize(item.size || 0)}) - See included image file`;
            
            // Add promise to fetch and add image to ZIP
            imagePromises.push(
              fetch(`/api/clipboard/get/${item.id}`)
                .then(response => response.blob())
                .then(blob => {
                  zip.file(`images/${item.filename}`, blob);
                  console.log(`Added image to ZIP: ${item.filename}`);
                })
                .catch(error => {
                  console.error('Error fetching image for ZIP:', item.filename, error);
                })
            );
          } else {
            content = item.preview || `File: ${item.filename || 'Unknown file'}`;
          }
          
          reportParts.push(`[${index + 1}] ${item.type.toUpperCase()} ITEM
Added: ${item.timestamp}
Type: ${item.content_type || 'Unknown'}
Size: ${formatClipboardSize(item.size || 0)}
${item.filename ? `Filename: ${item.filename}` : ''}

Contents:
========================================
${content}

========================================

`);
        }
        
        if (i + chunkSize < clipboardHistoryData.length) {
          const processedCount = Math.min(i + chunkSize, clipboardHistoryData.length);
          showToast(`📄 Processing... ${processedCount}/${clipboardHistoryData.length} items`, 1000);
          await new Promise(resolve => setTimeout(resolve, 0));
        }
      }
      
      reportParts.push(`
========================================
End of Report - Generated by Lanvan Clipboard System
ZIP Archive Contents:
- clipboard-history-report.txt (this report)
- images/ folder (containing ${imageItems} clipboard images)
========================================`);
      
      // Add text report to ZIP
      zip.file('clipboard-history-report.txt', reportParts.join(''));
      
      // Wait for all images to be added
      if (imagePromises.length > 0) {
        showToast(`🖼️ Adding ${imagePromises.length} images to ZIP...`, 2000);
        await Promise.all(imagePromises);
      }
      
      // Generate and download ZIP
      showToast('📦 Generating ZIP file...', 2000);
      const zipBlob = await zip.generateAsync({ type: 'blob' });
      
      const filename = `lanvan-clipboard-history-${timestamp}.zip`;
      const url = URL.createObjectURL(zipBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showToast(`📦 ZIP file downloaded: ${filename} (${clipboardHistoryData.length} items, ${imageItems} images)`, 4000);
      
    } else {
      // No images, create simple text file (existing logic)
      showToast('📄 Fetching full clipboard content for download...', 3000);
      
      const filename = `lanvan-clipboard-history-${timestamp}.txt`;
      const reportParts = [];
      
      reportParts.push(`LANVAN CLIPBOARD HISTORY REPORT
========================================
Generated: ${new Date().toLocaleString()}
Total Items: ${clipboardHistoryData.length}
Report Format: Plain Text

SUMMARY STATISTICS:
- Text Items: ${textItems}
- File Items: ${fileItems}
- Total Size: ${formatClipboardSize(totalSizeBytes)}

========================================
DETAILED CLIPBOARD ITEMS:
========================================

`);
      
      // Process text items
      const chunkSize = 5;
      for (let i = 0; i < clipboardHistoryData.length; i += chunkSize) {
        const chunk = clipboardHistoryData.slice(i, i + chunkSize);
        
        for (const [chunkIndex, item] of chunk.entries()) {
          const index = i + chunkIndex;
          
          let content = 'No content available';
          
          if (item.type === 'text') {
            try {
              const response = await fetch(`/api/clipboard/get/${item.id}`);
              const data = await response.json();
              if (data.status === 'success' && data.item && data.item.data) {
                content = data.item.data;
              } else {
                content = item.preview || 'Failed to fetch full content';
              }
            } catch (error) {
              content = item.preview || 'Error fetching full content';
            }
          } else {
            content = item.preview || `File: ${item.filename || 'Unknown file'}`;
          }
          
          reportParts.push(`[${index + 1}] ${item.type.toUpperCase()} ITEM
Added: ${item.timestamp}
Type: ${item.content_type || 'Unknown'}
Size: ${formatClipboardSize(item.size || 0)}
${item.filename ? `Filename: ${item.filename}` : ''}

Contents:
========================================
${content}

========================================

`);
        }
        
        if (i + chunkSize < clipboardHistoryData.length) {
          const processedCount = Math.min(i + chunkSize, clipboardHistoryData.length);
          showToast(`📄 Processing... ${processedCount}/${clipboardHistoryData.length} items`, 1000);
          await new Promise(resolve => setTimeout(resolve, 0));
        }
      }
      
      reportParts.push(`
========================================
End of Report - Generated by Lanvan Clipboard System
========================================`);
      
      // Create and download text file
      const reportContent = reportParts.join('');
      const blob = new Blob([reportContent], { type: 'text/plain' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      showToast(`📄 Clipboard history downloaded: ${filename} (${clipboardHistoryData.length} items)`, 4000);
    }
    
  } catch (error) {
    console.error('Error downloading clipboard history:', error);
    showToast('❌ Failed to download clipboard history', 3000);
  }
}

// Clear all clipboard history
function clearAllClipboardHistory() {
  if (!confirm('Are you sure you want to clear all clipboard history? This cannot be undone.')) {
    return;
  }
  
  fetch('/api/clipboard/clear', {
    method: 'DELETE'
  })
  .then(response => response.json())
  .then(data => {
    if (data.status === 'success') {
      showToast(data.msg, 3000);
      refreshClipboardHistory();
    } else {
      showToast(`❌ Failed to clear clipboard: ${data.msg}`, 4000);
    }
  })
  .catch(error => {
    console.error('Error clearing clipboard:', error);
    showToast('❌ Failed to clear clipboard', 4000);
  });
}

// Add clipboard functions to global scope
window.openClipboardModal = openClipboardModal;
window.closeClipboardModal = closeClipboardModal;
window.handleClipboardPaste = handleClipboardPaste;
window.addTextToClipboard = addTextToClipboard;
window.clearClipboardInput = clearClipboardInput;
window.refreshClipboardHistory = refreshClipboardHistory;
window.downloadClipboardHistory = downloadClipboardHistory;
window.downloadClipboardItem = downloadClipboardItem;
window.copyClipboardText = copyClipboardText;
window.removeClipboardItem = removeClipboardItem;
window.clearAllClipboardHistory = clearAllClipboardHistory;

  
</script>

<!-- 🔔 Toast Notification with Progress Bar Support -->
<div id="toast" style="
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: #333;
  color: #fff;
  padding: 0.8rem 1.2rem;
  border-radius: 8px;
  font-size: 0.9rem;
  display: none;
  box-shadow: 0 2px 6px rgba(0,0,0,0.2);
  z-index: 10005;
  cursor: pointer;
  transition: opacity 0.3s ease, background-color 0.2s ease, transform 0.3s ease;
  opacity: 1;
  max-width: 500px;
  min-width: 300px;
  word-wrap: break-word;
  overflow-wrap: break-word;
  hyphens: auto;
  -webkit-transform: translateX(-50%) translateZ(0);
  transform: translateX(-50%) translateZ(0);
  overflow: hidden;
  text-align: center;
  line-height: 1.4;
" title="Click to keep visible">
  <!-- Progress bar overlay -->
  <div id="toast-progress" style="
    position: absolute;
    bottom: 0;
    left: 0;
    height: 3px;
    width: 0%;
    background: linear-gradient(90deg, #4CAF50, #66BB6A);
    transition: width 0.3s ease, background 0.3s ease;
    z-index: 1;
  "></div>
</div>

<script>
  function completeProgress(color = 'green') {
    try {
      // Use cached DOM element
      let progressBar = DOM_CACHE.toastProgress;
      if (!progressBar) {
        progressBar = document.getElementById('toast-progress');
        if (progressBar) DOM_CACHE.toastProgress = progressBar;
      }
      if (!progressBar) return; // Safe guard for guest devices
      
      setProgressColor(color);
      progressBar.style.width = '100%';
      
      // Fade out after completion
      setTimeout(() => {
        if (progressBar) progressBar.style.width = '0%';
      }, 1000);
    } catch (err) {
      console.log('Progress completion skipped on this device');
    }
  }

  //  Show persistent toast with elapsed time (Legacy - replaced by new system)

  // 🎯 Handle download button clicks with direct download strategy - LANVan Ultra-Fast Implementation
  function setupDownloadHandlers() {
    // 🚀 PERFORMANCE: Clean up existing listeners first to prevent memory leaks
    document.querySelectorAll('.file-card a.download-btn').forEach(btn => {
      btn.replaceWith(btn.cloneNode(true));
    });
    
    document.querySelectorAll('.file-card a.download-btn').forEach(btn => {
      btn.addEventListener('click', async function handleDownloadClick(e) {
        e.preventDefault();

        const fileUrl = this.getAttribute('href');
        const fileName = this.closest('.file-card').querySelector('.file-name').textContent.trim();
        const isHTTPS = location.protocol === 'https:';

        // 📦 LANVan Direct Download Strategy - No Frontend Processing
        const CHUNK_THRESHOLD = LANVAN_CONFIG.CHUNK_THRESHOLD;
        const isEncFile = fileName.endsWith('.enc');

        // Quick file info check for strategy decision
        const startTime = Date.now();
        
        // Show single stable toast with blue progress bar
        showToast('⚡ Initializing download...', 0);
        startProgressAnimation('blue', 2000);

      try {
        // HEAD request to get file info
        const headResponse = await fetch(fileUrl, { method: 'HEAD' });
        if (!headResponse.ok) throw new Error('File info request failed');

        const contentLength = headResponse.headers.get('Content-Length');
        let fileSize = contentLength ? parseInt(contentLength) : 0;
        
        // 💾 If no Content-Length from server, try stored metadata
        if (!fileSize) {
          const storedMetadata = getFileMetadata(fileName);
          if (storedMetadata) {
            fileSize = storedMetadata.size;
          }
        }
        
        const fileSizeMB = (fileSize / 1024 / 1024).toFixed(2);
        const isLargeFile = fileSize >= CHUNK_THRESHOLD;

        // 🚀 ULTRA-FAST DIRECT DOWNLOAD STRATEGY:
        // No frontend processing, no chunking, no blob creation - just direct download
        
        const serverResponseTime = ((Date.now() - startTime) / 1000).toFixed(2);
        
        // Update toast with processing info - single stable message
        updateProgressToast(`📥 Processing ${fileSizeMB} MB download...`);

        // 🚀 DIRECT DOWNLOAD - Let browser handle everything natively
        const link = document.createElement('a');
        link.href = fileUrl;
        link.download = fileName;
        link.style.display = 'none';
        document.body.appendChild(link);
        
        // Trigger immediate download
        const downloadStartTime = Date.now(); // Separate timing for processing vs total
        link.click();
        document.body.removeChild(link);
        
        // 🕒 Separate timing calculations for accuracy
        const totalTime = ((Date.now() - startTime) / 1000).toFixed(2);
        const processingTime = ((downloadStartTime - startTime) / 1000).toFixed(3); // Time before download trigger
        const downloadTime = ((Date.now() - downloadStartTime) / 1000).toFixed(3);  // Time for download trigger
        
        // Create accurate stats for direct download
        const downloadStats = {
          type: 'direct_download_ultra_fast',
          filename: fileName,
          size: fileSizeMB + ' MB',
          time: totalTime + 's',
          speed: (fileSizeMB / parseFloat(totalTime)).toFixed(2) + ' MB/s',
          serverResponseTime: serverResponseTime + 's',
          processingTime: processingTime + 's', // Accurate processing time (separate calculation)
          downloadTime: downloadTime + 's',     // Download trigger time
          totalTime: totalTime + 's',
          protocol: isHTTPS ? 'HTTPS' : 'HTTP',
          aesEnabled: isEncFile,
          downloadType: isEncFile ? 'direct-enc' : (isLargeFile ? 'direct-large' : 'direct-small'),
          strategy: 'zero-processing-direct',
          timestamp: new Date().toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true })
        };
        saveStatsToLog(downloadStats);

        // Success message with accurate timing
        const protocolMsg = isHTTPS ? 'HTTPS' : 'HTTP';
        const completionMessage = `✅ Download complete via ${protocolMsg} (${fileSizeMB} MB) • ${totalTime}s total • ${processingTime}s processing`;
        
        // Complete progress bar and show final success (safe for all devices)
        completeProgress('blue');
        setTimeout(() => {
          console.log('🎯 Showing download completion toast:', completionMessage);
          console.log('🎯 DOM_CACHE status:', {
            toast: !!DOM_CACHE.toast,
            toastId: DOM_CACHE.toast ? DOM_CACHE.toast.id : 'no-toast',
            cacheKeys: Object.keys(DOM_CACHE)
          });
          
          // 🚀 PERFORMANCE: Optimized fallback with DOM cache update
          if (!DOM_CACHE.toast) {
            console.warn('⚠️ DOM_CACHE.toast not available, trying direct selection');
            DOM_CACHE.toast = document.getElementById('toast');
            if (DOM_CACHE.toast) {
              console.log('✅ Found toast directly, updated DOM_CACHE');
            }
          }
          
          showToast(completionMessage, 0, downloadStats);
        }, 1500); // Brief delay to let download start

      } catch (error) {
        // 🔄 Safe fallback - ensure download still works even if progress fails
        console.log('Download error or fallback needed:', error.message);
        
        // Try basic download as fallback for guest devices
        try {
          const link = document.createElement('a');
          link.href = fileUrl;
          link.download = fileName;
          link.style.display = 'none';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);
          
          const fallbackTime = ((Date.now() - startTime) / 1000).toFixed(2);
          showToast(`✅ Download initiated (fallback mode) • ${fallbackTime}s`, 3000);
        } catch (fallbackError) {
          showToast(`❌ Download failed: ${error.message}`, 5000);
        }
        console.error('Direct download error:', error);
      }
    });
  });
  }

  // Set up download handlers after DOM cache is ready
  document.addEventListener('DOMContentLoaded', () => {
    // Wait a bit to ensure DOM_CACHE is fully initialized
    setTimeout(() => {
      setupDownloadHandlers();
    }, 100);
  });

// 📁 ULTRA-FAST BACKUP FUNCTIONS (only used if direct download fails)

// 📥 Minimal processing download for emergencies only
async function downloadFileMinimal(fileUrl, fileName, fileSizeMB, requestStartTime) {
  try {
    showToast('⚡ Using minimal processing fallback...', 2000);
    
    // Create download link and trigger immediate download
    const link = document.createElement('a');
    link.href = fileUrl;
    link.download = fileName;
    link.style.display = 'none';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    const totalTime = ((Date.now() - requestStartTime) / 1000).toFixed(2);
    const protocolMsg = location.protocol === 'https:' ? 'HTTPS' : 'HTTP';
    
    // Create stats for minimal fallback download
    const downloadStats = {
      type: 'minimal_fallback_download',
      filename: fileName,
      size: fileSizeMB + ' MB',
      time: totalTime + 's',
      speed: (parseFloat(fileSizeMB) / parseFloat(totalTime)).toFixed(2) + ' MB/s',
      protocol: protocolMsg,
      strategy: 'minimal-fallback',
      timestamp: new Date().toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true })
    };
    
    setTimeout(() => {
      showToast(`✅ Minimal fallback download complete via ${protocolMsg} (${fileSizeMB} MB) • ${totalTime}s • Click anywhere to dismiss`, 0, downloadStats);
    }, 1500);
    
  } catch (err) {
    showToast('❌ Fallback download error: ' + err.message + ' • Click anywhere to dismiss', 0);
  }
}

// 🔄 Ultra-optimized regular download function - supports HTTP & HTTPS (BACKUP ONLY)
async function downloadFileRegular(fileUrl, fileName, fileSizeMB, requestStartTime) {
  try {
    const stopPersistentToast = showPersistentToast('⏳ Requesting file from server...');

    const response = await fetch(fileUrl);
    if (!response.ok) throw new Error('Download failed');

    // Calculate actual server response time (time until headers received)
    const serverResponseTime = ((Date.now() - requestStartTime) / 1000).toFixed(2);
    
    // Start tracking processing time (not downloading time)
    const processingStartTime = Date.now();
    stopPersistentToast();
    
    // Get file size for progress tracking
    const contentLength = response.headers.get('Content-Length');
    let actualFileSizeMB;
    let processedBytes = 0;
    let totalBytes = contentLength ? parseInt(contentLength) : 0;
    
    // 💾 If no Content-Length, try to get size from stored metadata
    if (!contentLength) {
      const storedMetadata = getFileMetadata(fileName);
      if (storedMetadata) {
        totalBytes = storedMetadata.size;
        actualFileSizeMB = (storedMetadata.size / (1024 * 1024)).toFixed(2);
      }
    } else {
      actualFileSizeMB = (parseInt(contentLength) / (1024 * 1024)).toFixed(2);
    }
    
    if (!contentLength && !totalBytes) {
      // If no content-length header and no stored metadata, ultra-fast download without size info
      const stopProcessingToast = showPersistentToast('⚙️ Ultra-fast processing...');
      
      const blob = await response.blob();
      actualFileSizeMB = (blob.size / (1024 * 1024)).toFixed(2);
      
      stopProcessingToast();
      showToast('⚙️ Finalizing ultra-fast download...', 1000);
      
      // Create blob URL and trigger download
      const blobUrl = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = blobUrl;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      window.URL.revokeObjectURL(blobUrl);
    } else {
      // We have size info - show optimized progress
      if (!actualFileSizeMB) {
        actualFileSizeMB = (totalBytes / (1024 * 1024)).toFixed(2);
      }
      
      // 🚀 Ultra-fast streaming with optimized progress tracking
      const reader = response.body.getReader();
      const chunks = [];
      let lastProgressUpdate = 0;
      const PROGRESS_UPDATE_INTERVAL = 250; // Update every 250ms for ultra-smooth progress
      
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        
        chunks.push(value);
        processedBytes += value.length;
        
        // Calculate progress percentage
        const progressPercent = totalBytes > 0 ? ((processedBytes / totalBytes) * 100).toFixed(1) : '0.0';
        const processingElapsed = ((Date.now() - processingStartTime) / 1000).toFixed(1);
        const processedMB = (processedBytes / 1024 / 1024).toFixed(1);
        const speed = processedBytes / (1024 * 1024) / ((Date.now() - processingStartTime) / 1000);
        
        // Update progress toast with speed tracking
        const now = Date.now();
        if (now - lastProgressUpdate >= PROGRESS_UPDATE_INTERVAL || done) {
          const sizeSource = contentLength ? "(server)" : "(stored)";
          showToast(`⚙️ Ultra-fast processing ${progressPercent}% (${processedMB}/${actualFileSizeMB} MB) @ ${speed.toFixed(1)} MB/s ${sizeSource} • ${processingElapsed}s`, 100);
          lastProgressUpdate = now;
        }
      }
      
      // Combine chunks and finalize
      showToast('⚙️ Finalizing ultra-fast download...', 1000);
      const blob = new Blob(chunks);
      const blobUrl = window.URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = blobUrl;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      a.remove();
      window.URL.revokeObjectURL(blobUrl);
    }

    // Calculate total processing time (not download time)
    const totalProcessingTime = ((Date.now() - processingStartTime) / 1000).toFixed(2);
    const totalTime = ((Date.now() - requestStartTime) / 1000).toFixed(2);
    const avgSpeed = totalBytes > 0 ? (totalBytes / (1024 * 1024) / parseFloat(totalProcessingTime)).toFixed(1) : 'N/A';
    
    // Save download stats to logs with accurate timing
    const downloadStats = {
      type: 'ultra_optimized_download',
      filename: fileName,
      size: actualFileSizeMB + ' MB',
      time: totalTime + 's',
      speed: avgSpeed + ' MB/s',
      serverResponseTime: serverResponseTime + 's',
      processingTime: totalProcessingTime + 's',
      processingSpeed: avgSpeed + ' MB/s',
      totalTime: totalTime + 's',
      protocol: location.protocol === 'https:' ? 'HTTPS' : 'HTTP',
      aesEnabled: fileName.endsWith('.enc'),
      downloadType: 'ultra-optimized',
      timestamp: new Date().toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true }),
      startTime: new Date(requestStartTime).toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true }),
      endTime: new Date().toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true })
    };
    saveStatsToLog(downloadStats);

    // Enhanced completion toast with speed information
    const protocolMsg = location.protocol === 'https:' ? 'HTTPS' : 'HTTP';
    const completionMessage = `✅ Ultra-optimized download complete via ${protocolMsg} (${actualFileSizeMB} MB) • Server: ${serverResponseTime}s • Processing: ${totalProcessingTime}s @ ${avgSpeed} MB/s`;
    
    // Trigger-based download detection instead of time-based delay
    detectDownloadCompletion(completionMessage, downloadStats);
    
  } catch (err) {
    // Stop any running toasts on error
    if (typeof stopPersistentToast === 'function') stopPersistentToast();
    showToast('❌ Download error: ' + err.message + ' • Click anywhere to dismiss', 0);
    throw err; // Re-throw for parent handler
  }
}

// 📦 High-performance chunked download function for large files (≥250MB) - supports HTTP & HTTPS
async function downloadFileChunked(fileUrl, fileName, fileSize, fileSizeMB, requestStartTime) {
  const isHTTPS = location.protocol === 'https:';
  const protocolMsg = isHTTPS ? "HTTPS" : "HTTP";
  const DOWNLOAD_CHUNK_SIZE = 16 * 1024 * 1024; // 16MB chunks (16x larger than before for much faster processing)
  const totalChunks = Math.ceil(fileSize / DOWNLOAD_CHUNK_SIZE);
  
  try {
    const stopInitialToast = showPersistentToast('⏳ Preparing high-performance chunked download...');
    
    // Start processing time tracking
    const processingStartTime = Date.now();
    let processedChunks = 0;
    const chunks = [];
    
    stopInitialToast();
    
    // 🚀 Process chunks with much larger sizes for faster performance
    for (let i = 0; i < totalChunks; i++) {
      const start = i * DOWNLOAD_CHUNK_SIZE;
      const end = Math.min(start + DOWNLOAD_CHUNK_SIZE, fileSize);
      
      // Calculate progress percentage
      const progressPercent = ((i + 1) / totalChunks * 100).toFixed(1);
      const processingElapsed = ((Date.now() - processingStartTime) / 1000).toFixed(1);
      const chunkSizeMB = ((end - start) / (1024 * 1024)).toFixed(1);
      
      // Show processing progress with chunk size info
      showToast(`⚙️ Processing 16MB chunks ${progressPercent}% (${i + 1}/${totalChunks}) • Chunk: ${chunkSizeMB}MB • Processing: ${processingElapsed}s`, 100);
      
      try {
        const response = await fetch(fileUrl, {
          headers: {
            'Range': `bytes=${start}-${end - 1}`
          }
        });
        
        if (!response.ok) throw new Error(`Chunk ${i + 1} failed`);
        
        const chunkBlob = await response.blob();
        chunks.push(chunkBlob);
        processedChunks++;
        
      } catch (chunkError) {
        showToast(`❌ Processing failed at chunk ${i + 1}: ${chunkError.message}`, 5000);
        return;
      }
    }
    
    // All chunks processed, now combine them
    const totalProcessingTime = ((Date.now() - processingStartTime) / 1000).toFixed(1);
    showToast(`🔗 Combining ${processedChunks} large chunks... (Processing: ${totalProcessingTime}s)`);
    
    // Combine all chunks into final blob
    const combinedBlob = new Blob(chunks);
    
    // Trigger download
    const blobUrl = window.URL.createObjectURL(combinedBlob);
    const a = document.createElement('a');
    a.href = blobUrl;
    a.download = fileName;
    document.body.appendChild(a);
    a.click();
    a.remove();
    window.URL.revokeObjectURL(blobUrl);
    
    // Calculate final stats
    const totalTime = ((Date.now() - requestStartTime) / 1000).toFixed(1);
    
    const downloadStats = {
      type: 'high_performance_chunked_download',
      filename: fileName,
      size: fileSizeMB + ' MB',
      time: totalTime + 's',
      speed: (fileSizeMB / parseFloat(totalTime)).toFixed(2) + ' MB/s',
      totalChunks: totalChunks,
      chunkSize: '16MB',
      processingTime: totalProcessingTime + 's',
      totalTime: totalTime + 's',
      protocol: protocolMsg,
      aesEnabled: fileName.endsWith('.enc'),
      timestamp: new Date().toLocaleString('en-US', { hour: 'numeric', minute: 'numeric', second: 'numeric', hour12: true })
    };
    saveStatsToLog(downloadStats);
    
    // Success message with performance info
    showToast(`✅ High-performance chunked download complete via ${protocolMsg} (${fileSizeMB} MB) • Processing: ${totalProcessingTime}s • Total: ${totalTime}s • 16MB chunks • Click anywhere to dismiss`, 0, downloadStats);
    
  } catch (error) {
    showToast(`❌ High-performance chunked download failed: ${error.message} • Click anywhere to dismiss`, 0);
    console.error('High-performance chunked download error:', error);
  }
}

  // 💾 Store file metadata for downloads (fixes "unknown size" issue)
  function storeFileMetadata(files, totalSize) {
    const metadata = JSON.parse(localStorage.getItem('fileMetadata') || '{}');
    
    for (let file of files) {
      metadata[file.name] = {
        size: file.size,
        sizeFormatted: (file.size / (1024 * 1024)).toFixed(2) + ' MB',
        type: file.type || 'unknown',
        uploadDate: new Date().toISOString(),
        timestamp: Date.now()
      };
    }
    
    // 🚀 PERFORMANCE: Optimize metadata cleanup with for...in loop
    const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
    for (const filename in metadata) {
      if (metadata[filename].timestamp < thirtyDaysAgo) {
        delete metadata[filename];
      }
    }
    
    localStorage.setItem('fileMetadata', JSON.stringify(metadata));
  }

  // 📁 Get stored file metadata (for downloads)
  function getFileMetadata(filename) {
    const metadata = JSON.parse(localStorage.getItem('fileMetadata') || '{}');
    return metadata[filename] || null;
  }

  // Missing progress functions for compatibility
  function setProgressColor(color) {
    try {
      // Use cached DOM element instead of repeated getElementById
      let progressBar = DOM_CACHE.toastProgress;
      if (!progressBar) {
        progressBar = document.getElementById('toast-progress');
        if (progressBar) DOM_CACHE.toastProgress = progressBar;
      }
      if (!progressBar) return; // Safe guard for guest devices
      
      if (color === 'blue') {
        progressBar.style.background = 'linear-gradient(90deg, #2196F3, #42A5F5)';
      } else if (color === 'green') {
        progressBar.style.background = 'linear-gradient(90deg, #4CAF50, #66BB6A)';
      } else {
        progressBar.style.background = color;
      }
    } catch (err) {
      console.log('Progress color update skipped on this device');
    }
  }

  function updateProgress(percentage, color = 'green') {
    try {
      // Use cached DOM element
      let progressBar = DOM_CACHE.toastProgress;
      if (!progressBar) {
        progressBar = document.getElementById('toast-progress');
        if (progressBar) DOM_CACHE.toastProgress = progressBar;
      }
      if (!progressBar) return; // Safe guard for guest devices
      
      setProgressColor(color);
      progressBar.style.width = Math.min(100, Math.max(0, percentage)) + '%';
    } catch (err) {
      console.log('Progress update skipped on this device');
    }
  }

  function startProgressAnimation(color = 'green', duration = 2000) {
    try {
      setProgressColor(color);
      // Use cached DOM element
      let progressBar = DOM_CACHE.toastProgress;
      if (!progressBar) {
        progressBar = document.getElementById('toast-progress');
        if (progressBar) DOM_CACHE.toastProgress = progressBar;
      }
      if (!progressBar) return; // Safe guard for guest devices
      
      progressBar.style.width = '0%';
      
      // Animate to 90% over the duration
      const startTime = Date.now();
      const animate = () => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(90, (elapsed / duration) * 90);
        if (progressBar) progressBar.style.width = progress + '%';
        
        if (progress < 90 && progressBar) {
          requestAnimationFrame(animate);
        }
      };
      requestAnimationFrame(animate);
    } catch (err) {
      console.log('Progress animation skipped on this device');
    }
  }

  function showPersistentToast(message) {
    showToast(message, -1); // -1 means indefinite
    return function stopPersistentToast() {
      hideToast();
    };
  }
</script>

<!-- 📊 Device Logs Modal -->
<div id="deviceLogsModal" style="
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.5);
  z-index: 10001;
  padding: 1rem;
  box-sizing: border-box;
">
  <div style="
    background: var(--section-bg);
    color: var(--text-color);
    border-radius: 15px;
    padding: 2rem;
    max-width: 900px;
    width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    margin: 0 auto;
    margin-top: 2vh;
  ">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem;">
      <h3 style="margin: 0; color: var(--text-color); font-size: 1.3rem;">📊 Device Logs</h3>
      <button onclick="closeDeviceLogsModal()" style="
        background: #e74c3c;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 8px;
        cursor: pointer;
        font-size: 0.9rem;
      ">
        ✕ Close
      </button>
    </div>
    
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
      <h4 style="margin: 0; color: var(--text-color); font-size: 1.1rem;">📱 This Device Session Only</h4>
      <div style="display: flex; gap: 0.5rem;">
        <button onclick="downloadDeviceLogs()" id="downloadLogsBtn" style="background: #28a745; color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 4px; font-size: 0.85rem; cursor: pointer;">
          📄 Download Logs
        </button>
        <button onclick="clearDeviceLogs()" id="clearLogsBtn" style="background: var(--settings-bg); color: white; border: none; padding: 0.4rem 0.8rem; border-radius: 4px; font-size: 0.85rem; cursor: pointer;">
          🧹 Clear Logs
        </button>
      </div>
    </div>
    
    <div id="deviceLogsStats" style="background: var(--input-bg); padding: 0.8rem; border-radius: 6px; margin-bottom: 1rem; font-size: 0.9rem; color: var(--text-color); border: 1px solid var(--border-color);">
      <!-- Logs stats will be populated here -->
    </div>
    
    <div id="deviceLogsSection" style="display: block;">
      <div id="deviceLogsContent" style="max-height: 400px; overflow-y: auto; background: var(--input-bg); padding: 1rem; border-radius: 8px; border: 1px solid var(--border-color); color: var(--text-color) !important;">
        <!-- Logs content will be populated here -->
      </div>
      <div id="deviceLogsPagination" style="text-align: center; margin-top: 1rem; display: none;">
        <!-- Pagination controls will be populated here -->
      </div>
    </div>
  </div>
</div>

<!-- 📋 Clipboard Modal -->
<div id="clipboardModal" style="
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.6);
  z-index: 10000;
  align-items: center;
  justify-content: center;
">
  <div style="
    background: white;
    border-radius: 15px;
    width: 90%;
    max-width: 800px;
    max-height: 90vh;
    overflow-y: auto;
    box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    margin: 0 auto;
    margin-top: 2vh;
  ">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1.5rem; padding: 1.5rem 1.5rem 0 1.5rem;">
      <h3 style="margin: 0; color: #333; font-size: 1.3rem;">📋 Clipboard System</h3>
      <div style="display: flex; gap: 0.5rem; align-items: center;">
        <div style="position: relative;">
          <button onclick="showSwitchDropdown(event, 'switchDropdownClipboard')" class="clipboard-btn" style="
            background: linear-gradient(135deg, #6c5ce7, #a29bfe);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(108, 92, 231, 0.3);
          " title="Switch between File Sharing and Clipboard">
            🔄 Switch
          </button>
          <div id="switchDropdownClipboard" style="display:none; position:absolute; right:0; top:110%; background:white; border:1px solid #ccc; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.15); min-width:150px; z-index:10001;">
            <div style="padding:0.5rem 1rem; cursor:pointer;" onclick="switchToPage('file')">📁 File Sharing</div>
            <div style="padding:0.5rem 1rem; cursor:pointer;" onclick="switchToPage('clipboard')">📋 Clipboard</div>
          </div>
        </div>
        <button onclick="closeClipboardModal()" style="
          background: #e74c3c;
          color: white;
          border: none;
          padding: 0.5rem 1rem;
          border-radius: 8px;
          cursor: pointer;
          font-size: 0.9rem;
        ">
          ✕ Close
        </button>
      </div>
    </div>
    
    <!-- Clipboard Input Section -->
    <div style="padding: 0 1.5rem;">
      <div style="background: #f8f9fa; padding: 1rem; border-radius: 8px; margin-bottom: 1.5rem;">
        <h4 style="margin: 0 0 1rem 0; color: #333;">Add to Clipboard</h4>
        
        <!-- Paste Area -->
        <div style="margin-bottom: 1rem;">
          <label style="display: block; margin-bottom: 0.5rem; font-weight: bold; color: #555;">Paste Text/Content:</label>
          <textarea id="clipboardTextInput" placeholder="Type or paste text content here..." style="
            width: 100%;
            height: 100px;
            padding: 0.5rem;
            border: 2px dashed #ddd;
            border-radius: 6px;
            resize: vertical;
            font-family: monospace;
            font-size: 0.9rem;
            white-space: pre-wrap;
            word-wrap: break-word;
          " onpaste="handleClipboardPaste(event)"></textarea>
          <small style="color: #666; font-size: 0.8rem;">
            💡 Supports: Text content and images (paste images directly with Ctrl+V)
          </small>
        </div>
        
        <!-- Action Buttons -->
        <div style="display: flex; gap: 0.5rem;">
          <button id="addTextToClipboardBtnModal" style="
            background: #28a745;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s ease;
          ">
            📝 Add Text
          </button>
          <button onclick="clearClipboardInput()" style="
            background: var(--settings-bg);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
          ">
            🧹 Clear Input
          </button>
        </div>
      </div>
    </div>
    
    <!-- Clipboard History Section -->
    <div style="padding: 0 1.5rem 1.5rem 1.5rem;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
        <h4 style="margin: 0; color: #333;">📚 Clipboard History</h4>
        <div style="display: flex; gap: 0.5rem;">
          <button onclick="refreshClipboardHistory()" style="
            background: #17a2b8;
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
          ">
            🔄 Refresh
          </button>
          <button onclick="downloadClipboardHistory()" style="
            background: #28a745;
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
          ">
            📄 Download History
          </button>
          <button onclick="clearAllClipboardHistory()" style="
            background: #dc3545;
            color: white;
            border: none;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            font-size: 0.85rem;
            cursor: pointer;
          ">
            🧹 Clear All
          </button>
        </div>
      </div>
      
      <div id="clipboardHistoryContent" style="
        max-height: 300px;
        overflow-y: auto;
        background: #f9f9f9;
        padding: 1rem;
        border-radius: 8px;
        border: 1px solid #e0e0e0;
      ">
        <div style="text-align: center; color: var(--text-color); opacity: 0.6; padding: 2rem;">
          <div style="font-size: 3rem; margin-bottom: 1rem;">📋</div>
          <div>No clipboard items yet</div>
          <div style="font-size: 0.9rem; margin-top: 0.5rem;">Add content above to get started</div>
        </div>
      </div>
    </div>
  </div>
</div>

    </div>
  </div>
</div>

<script>
// Switch button dropdown and navigation logic (inlined to avoid 404 issues)
function showSwitchDropdown(event, dropdownId) {
  event.stopPropagation();
  const dropdown = document.getElementById(dropdownId);
  if (dropdown.style.display === 'block') {
    dropdown.style.display = 'none';
  } else {
    dropdown.style.display = 'block';
    // Hide dropdown if clicked outside
    document.addEventListener('click', function handler(e) {
      if (!dropdown.contains(e.target)) {
        dropdown.style.display = 'none';
        document.removeEventListener('click', handler);
      }
    });
  }
}
function switchToPage(page) {
  // Hide all switch dropdowns before switching
  var dropdowns = [
    document.getElementById('switchDropdownMain'),
    document.getElementById('switchDropdownClipboard')
  ];
  dropdowns.forEach(function(dd) {
    if (dd) dd.style.display = 'none';
  });
  
  // Get the sections by ID
  const fileTransferSection = document.getElementById('fileTransferSection');
  const fileListSection = document.getElementById('fileListSection');
  const clipboardSection = document.getElementById('clipboardSection');
  
  // Get all tick indicators
  const fileTickMain = document.getElementById('fileTickMain');
  const clipboardTickMain = document.getElementById('clipboardTickMain');
  const fileTickClipboard = document.getElementById('fileTickClipboard');
  const clipboardTickClipboard = document.getElementById('clipboardTickClipboard');
  
  // Add smooth transition effect with opacity
  const sections = [fileTransferSection, fileListSection, clipboardSection];
  sections.forEach(section => {
    if (section) section.style.opacity = '0.7';
  });
  
  // Use setTimeout to allow smooth transition
  setTimeout(() => {
    if (page === 'clipboard') {
      // Update current active section tracker
      currentActiveSection = 'clipboard';
      
      // Show clipboard section, hide file sections
      if (fileTransferSection) {
        fileTransferSection.style.display = 'none';
        fileTransferSection.style.opacity = '1';
      }
      if (fileListSection) {
        fileListSection.style.display = 'none';
        fileListSection.style.opacity = '1';
      }
      if (clipboardSection) {
        clipboardSection.style.display = 'block';
        clipboardSection.style.opacity = '1';
      }
      
      // Update tick indicators - show clipboard ticks, hide file ticks
      if (fileTickMain) fileTickMain.style.display = 'none';
      if (fileTickClipboard) fileTickClipboard.style.display = 'none';
      if (clipboardTickMain) clipboardTickMain.style.display = 'inline';
      if (clipboardTickClipboard) clipboardTickClipboard.style.display = 'inline';
      
      // Update page title/URL without navigation (preserves uploads)
      history.pushState({page: 'clipboard'}, 'LANVan - Clipboard', '/clipboard');
      document.title = 'LANVan - Clipboard';
      
    } else if (page === 'file') {
      // Update current active section tracker
      currentActiveSection = 'file';
      
      // Show file sections, hide clipboard section
      if (fileTransferSection) {
        fileTransferSection.style.display = 'block';
        fileTransferSection.style.opacity = '1';
      }
      if (fileListSection) {
        fileListSection.style.display = 'block';
        fileListSection.style.opacity = '1';
      }
      if (clipboardSection) {
        clipboardSection.style.display = 'none';
        clipboardSection.style.opacity = '1';
      }
      
      // Update tick indicators - show file ticks, hide clipboard ticks
      if (fileTickMain) fileTickMain.style.display = 'inline';
      if (fileTickClipboard) fileTickClipboard.style.display = 'inline';
      if (clipboardTickMain) clipboardTickMain.style.display = 'none';
      if (clipboardTickClipboard) clipboardTickClipboard.style.display = 'none';
      
      // Update page title/URL without navigation (preserves uploads)
      history.pushState({page: 'file'}, 'LANVan - File Transfer', '/');
      document.title = 'LANVan - File Transfer';
    }
  }, 100); // Small delay for smooth transition
  
  // Trigger any necessary updates for the visible section
  setTimeout(() => {
    if (page === 'file') {
      // When switching back to file section, refresh the file list to show any new files
      if (typeof refreshFileList === 'function') {
        refreshFileList();
      } else if (typeof updateFileList === 'function') {
        updateFileList();
      }
    } else if (page === 'clipboard') {
      if (typeof refreshClipboardHistory === 'function') {
        refreshClipboardHistory();
      }
    }
  }, 150); // Slight delay to ensure sections are visible
  
  // Show a brief toast notification
  if (typeof showToast === 'function') {
    const sectionName = page === 'clipboard' ? 'Clipboard' : 'File Transfer';
    showToast(`📱 Switched to ${sectionName}`, 1500);
  }
}

// Handle browser back/forward buttons to preserve upload state
window.addEventListener('popstate', function(event) {
  if (event.state && event.state.page) {
    // Switch to the page without updating history (since we're handling popstate)
    const targetPage = event.state.page;
    
    // Update current active section tracker
    currentActiveSection = targetPage;
    console.log(`🔙 Browser navigation - active section: ${currentActiveSection}`);
    
    const fileTransferSection = document.getElementById('fileTransferSection');
    const fileListSection = document.getElementById('fileListSection');
    const clipboardSection = document.getElementById('clipboardSection');
    
    // Get all tick indicators
    const fileTickMain = document.getElementById('fileTickMain');
    const clipboardTickMain = document.getElementById('clipboardTickMain');
    const fileTickClipboard = document.getElementById('fileTickClipboard');
    const clipboardTickClipboard = document.getElementById('clipboardTickClipboard');
    
    if (targetPage === 'clipboard') {
      if (fileTransferSection) fileTransferSection.style.display = 'none';
      if (fileListSection) fileListSection.style.display = 'none';
      if (clipboardSection) clipboardSection.style.display = 'block';
      
      // Update tick indicators for clipboard
      if (fileTickMain) fileTickMain.style.display = 'none';
      if (fileTickClipboard) fileTickClipboard.style.display = 'none';
      if (clipboardTickMain) clipboardTickMain.style.display = 'inline';
      if (clipboardTickClipboard) clipboardTickClipboard.style.display = 'inline';
      
      document.title = 'LANVan - Clipboard';
    } else {
      if (fileTransferSection) fileTransferSection.style.display = 'block';
      if (fileListSection) fileListSection.style.display = 'block';
      if (clipboardSection) clipboardSection.style.display = 'none';
      
      // Update tick indicators for file transfer
      if (fileTickMain) fileTickMain.style.display = 'inline';
      if (fileTickClipboard) fileTickClipboard.style.display = 'inline';
      if (clipboardTickMain) clipboardTickMain.style.display = 'none';
      if (clipboardTickClipboard) clipboardTickClipboard.style.display = 'none';
      
      document.title = 'LANVan - File Transfer';
      
      // When navigating back to file section, refresh file list to show any new files
      if (typeof refreshFileList === 'function') {
        setTimeout(() => refreshFileList(), 100);
      }
    }
  }
});
</script>
<script>
// ✅ Save toggle state when user changes it
document.addEventListener('DOMContentLoaded', () => {
  const aesToggle = document.getElementById('enableEncryption');
  if (!aesToggle) return;

  const isHTTP = location.protocol === 'http:';
  
  // 🛡️ NEW LOGIC: Allow AES over HTTP only with HTTP-Safe mode
  if (isHTTP) {
    // For HTTP, enable AES toggle but show warning about HTTP-Safe requirement
    aesToggle.disabled = false;
    const toggleContainer = aesToggle.closest('.toggle-switch').parentElement;
    toggleContainer.style.opacity = '1';
    toggleContainer.title = 'AES over HTTP requires HTTP-Safe Mode for security. Enable both toggles for secure encryption.';
    
    // Restore saved state
    const saved = localStorage.getItem('aes_enabled');
    if (saved !== null) {
      aesToggle.checked = saved === '1';
    }
  } else {
    // For HTTPS, restore saved state and enable toggle
    aesToggle.disabled = false;
    const saved = localStorage.getItem('aes_enabled');
    if (saved !== null) {
      aesToggle.checked = saved === '1';
    }
  }

  // Save state on change (for both HTTP and HTTPS)
  aesToggle.addEventListener('change', () => {
    localStorage.setItem('aes_enabled', aesToggle.checked ? '1' : '0');
    
    // 🛡️ HTTP-Safe mode is now automatic - no toggle needed
    if (isHTTP && aesToggle.checked) {
      console.log('🛡️ HTTP-Safe mode automatically enabled for HTTP connection');
      showToast('🛡️ HTTP-Safe mode automatically enabled for secure encryption!', 4000);
    }
  });

  // 🛡️ HTTP-Safe mode is now automatic - no toggle management needed

  // 🌙 Dark Mode Toggle Functionality
  const darkModeToggle = DOM_CACHE.darkModeToggle;
  if (darkModeToggle) {
    // Load saved dark mode preference
    const savedDarkMode = localStorage.getItem('dark_mode_enabled');
    if (savedDarkMode !== null) {
      const isDarkMode = savedDarkMode === '1';
      darkModeToggle.checked = isDarkMode;
      applyDarkMode(isDarkMode);
    } else {
      // Check system preference
      const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      darkModeToggle.checked = prefersDark;
      applyDarkMode(prefersDark);
    }

    // Save state on change
    darkModeToggle.addEventListener('change', () => {
      const isDarkMode = darkModeToggle.checked;
      localStorage.setItem('dark_mode_enabled', isDarkMode ? '1' : '0');
      applyDarkMode(isDarkMode);
      
      // Show toast notification
      showToast(isDarkMode ? '🌙 Dark mode enabled' : '☀️ Light mode enabled', 2000);
    });

    // Listen for system theme changes
    if (window.matchMedia) {
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
        // Only auto-switch if user hasn't manually set preference
        if (localStorage.getItem('dark_mode_enabled') === null) {
          darkModeToggle.checked = e.matches;
          applyDarkMode(e.matches);
        }
      });
    }
  }

  // 🌙 Apply Dark Mode Function
  function applyDarkMode(isDarkMode) {
    if (isDarkMode) {
      document.documentElement.setAttribute('data-theme', 'dark');
    } else {
      document.documentElement.removeAttribute('data-theme');
    }
    
    // Update dark mode toggle text based on current mode
    const darkModeLabel = document.getElementById('darkModeLabel');
    if (darkModeLabel) {
      if (isDarkMode) {
        darkModeLabel.innerHTML = '<b>🌙 Dark Mode</b>';
      } else {
        darkModeLabel.innerHTML = '<b>☀️ Light Mode</b>';
      }
    }
    
    // Update protocol status hover colors for dark mode
    updateProtocolStatusHover(isDarkMode);
    
    // Fix any remaining hardcoded colors dynamically
    fixRemainingColors(isDarkMode);
  }

  // Fix remaining hardcoded colors that CSS might miss
  function fixRemainingColors(isDarkMode) {
    if (isDarkMode) {
      // Fix any elements with hardcoded #333 color
      const darkTextElements = document.querySelectorAll('[style*="color: #333"], [style*="color:#333"], [style*="color: #666"], [style*="color:#666"], [style*="color: #999"], [style*="color:#999"]');
      darkTextElements.forEach(el => {
        el.style.color = 'var(--text-color)';
      });
      
      // Fix any white background divs
      const whiteBgElements = document.querySelectorAll('[style*="background: #fff"], [style*="background-color: #fff"], [style*="background: #f8f9fa"], [style*="background: white"]');
      whiteBgElements.forEach(el => {
        el.style.backgroundColor = 'var(--section-bg)';
        el.style.color = 'var(--text-color)';
      });
      
      // Fix file names and clipboard items specifically
      const fileNameElements = document.querySelectorAll('.file-name, .upload-file-name');
      fileNameElements.forEach(el => {
        el.style.color = 'var(--text-color)';
      });
      
      // Fix clipboard items
      const clipboardElements = document.querySelectorAll('#clipboardHistoryContent div');
      clipboardElements.forEach(el => {
        if (el.style.color && (el.style.color.includes('#333') || el.style.color.includes('#666') || el.style.color.includes('#999'))) {
          el.style.color = 'var(--text-color)';
        }
      });
      
      // Fix labels and other text elements
      const textElements = document.querySelectorAll('label, span:not(.slider), .file-name, strong');
      textElements.forEach(el => {
        // Skip the mDNS hint text to preserve green color
        if (el.id === 'qrHintText' && el.innerHTML.includes('mDNS:')) {
          return;
        }
        if (!el.classList.contains('slider') && !el.classList.contains('toggle-text')) {
          if (el.style.color && (el.style.color.includes('#333') || el.style.color.includes('#666'))) {
            el.style.color = 'var(--text-color)';
          }
        }
      });
    } else {
      // Reset to light mode colors
      const allElements = document.querySelectorAll('*');
      allElements.forEach(el => {
        if (el.style.color && el.style.color.includes('var(--text-color)')) {
          el.style.color = '';
        }
        if (el.style.backgroundColor && el.style.backgroundColor.includes('var(--')) {
          el.style.backgroundColor = '';
        }
      });
    }
  }

  // Update protocol status hover behavior for dark mode
  function updateProtocolStatusHover(isDarkMode) {
    const protocolStatus = DOM_CACHE.protocolStatus;
    if (protocolStatus) {
      if (isDarkMode) {
        protocolStatus.onmouseover = function() { this.style.backgroundColor = '#1e40af'; };
        protocolStatus.onmouseout = function() { this.style.backgroundColor = 'var(--protocol-bg)'; };
      } else {
        protocolStatus.onmouseover = function() { this.style.backgroundColor = '#d0e9f7'; };
        protocolStatus.onmouseout = function() { this.style.backgroundColor = 'var(--protocol-bg)'; };
      }
    }
  }

  // 📋 Auto-load clipboard history for clipboard-only pages
  if (typeof show_clipboard_only !== 'undefined' && show_clipboard_only) {
    // Load clipboard history immediately after page loads
    setTimeout(() => {
      if (typeof refreshClipboardHistory === 'function') {
        refreshClipboardHistory();
        console.log('📋 Auto-loaded clipboard history after page refresh');
      }
    }, 500);
  }

  // Show welcome message based on protocol (only once per session)
  if (!sessionStorage.getItem('welcome_shown')) {
    setTimeout(() => {
      const isHTTP = location.protocol === 'http:';
      if (isHTTP) {
        showToast('🌐 Lanvan is ready for file transfers.', 4000);
      } else {
        showToast('🔒 HTTPS mode active - Enhanced security enabled.', 4000);
      }
      sessionStorage.setItem('welcome_shown', '1');
    }, 2000);
  }
});

// Mark that the main page loaded successfully (for loading page optimization)
try {
  sessionStorage.setItem('lanvan_page_loaded_successfully', Date.now().toString());
  // Also set a flag that resources are working
  sessionStorage.setItem('lanvan_resources_ready', 'true');
} catch (e) {
  // Ignore storage errors
}
</script>

</body>
</html>
